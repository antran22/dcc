# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Job {
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

interface ObjectWithMetadata {
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
}

"New in Saleor 3.1. Represents a delivery method chosen for the checkout. `Warehouse` type is used when checkout is marked as \"click and collect\" and `ShippingMethod` otherwise. Note: this feature is in a preview state and can be subject to changes at later point."
union DeliveryMethod = ShippingMethod | Warehouse

union TranslatableItem = AttributeTranslatableContent | AttributeValueTranslatableContent | CategoryTranslatableContent | CollectionTranslatableContent | MenuItemTranslatableContent | PageTranslatableContent | ProductTranslatableContent | ProductVariantTranslatableContent | SaleTranslatableContent | ShippingMethodTranslatableContent | VoucherTranslatableContent

"_Entity union as defined by Federation spec."
union _Entity = Address | App | Category | Collection | Group | PageType | Product | ProductMedia | ProductType | ProductVariant | User

"Create a new address for the customer."
type AccountAddressCreate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user instance for which the address was created."
    user: User
}

"Delete an address of the logged-in user."
type AccountAddressDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user instance for which the address was deleted."
    user: User
}

"Updates an address of the logged-in user."
type AccountAddressUpdate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user object for which the address was edited."
    user: User
}

"Remove user account."
type AccountDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    user: User
}

type AccountError {
    "A type of address that causes the error."
    addressType: AddressTypeEnum
    "The error code."
    code: AccountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Register a new user."
type AccountRegister {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "Informs whether users need to confirm their email address."
    requiresConfirmation: Boolean
    user: User
}

"Sends an email with the account removal link for the logged-in user."
type AccountRequestDeletion {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
}

"Sets a default address for the authenticated user."
type AccountSetDefaultAddress {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "An updated user instance."
    user: User
}

"Updates the account of the logged-in user."
type AccountUpdate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    user: User
}

"Represents user address data."
type Address implements Node {
    city: String!
    cityArea: String!
    companyName: String!
    "Shop's default country."
    country: CountryDisplay!
    countryArea: String!
    firstName: String!
    id: ID!
    "Address is user's default billing address."
    isDefaultBillingAddress: Boolean
    "Address is user's default shipping address."
    isDefaultShippingAddress: Boolean
    lastName: String!
    phone: String
    postalCode: String!
    streetAddress1: String!
    streetAddress2: String!
}

"Creates user address."
type AddressCreate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user instance for which the address was created."
    user: User
}

"Deletes an address."
type AddressDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user instance for which the address was deleted."
    user: User
}

"Sets a default address for the given user."
type AddressSetDefault {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "An updated user instance."
    user: User
}

"Updates an address."
type AddressUpdate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    address: Address
    errors: [AccountError!]!
    "A user object for which the address was edited."
    user: User
}

type AddressValidationData {
    addressFormat: String
    addressLatinFormat: String
    allowedFields: [String]
    cityAreaChoices: [ChoiceValue]
    cityAreaType: String
    cityChoices: [ChoiceValue]
    cityType: String
    countryAreaChoices: [ChoiceValue]
    countryAreaType: String
    countryCode: String
    countryName: String
    postalCodeExamples: [String]
    postalCodeMatchers: [String]
    postalCodePrefix: String
    postalCodeType: String
    requiredFields: [String]
    upperFields: [String]
}

"Represents allocation."
type Allocation implements Node {
    id: ID!
    "Quantity allocated for orders."
    quantity: Int!
    "The warehouse were items were allocated."
    warehouse: Warehouse!
}

"Represents app data."
type App implements Node & ObjectWithMetadata {
    "Description of this app."
    aboutApp: String
    "JWT token used to authenticate by thridparty app."
    accessToken: String
    "Url to iframe with the app."
    appUrl: String
    "Url to iframe with the configuration for the app."
    configurationUrl: String
    "The date and time when the app was created."
    created: DateTime
    "Description of the data privacy defined for this app."
    dataPrivacy: String
    "Url to details about the privacy policy on the app owner page."
    dataPrivacyUrl: String
    "New in Saleor 3.1. App's dashboard extensions. Note: this feature is in a preview state and can be subject to changes at later point."
    extensions: [AppExtension!]!
    "Homepage of the app."
    homepageUrl: String
    id: ID!
    "Determine if app will be set active or not."
    isActive: Boolean
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of the app."
    name: String
    "List of the app's permissions."
    permissions: [Permission]
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Support page for the app."
    supportUrl: String
    "Last 4 characters of the tokens."
    tokens: [AppToken]
    "Type of the app."
    type: AppTypeEnum
    "Version number of the app."
    version: String
    "List of webhooks assigned to this app."
    webhooks: [Webhook]
}

"Activate the app."
type AppActivate {
    app: App
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
}

type AppCountableConnection {
    edges: [AppCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AppCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: App!
}

"Creates a new app."
type AppCreate {
    app: App
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The newly created authentication token."
    authToken: String
    errors: [AppError!]!
}

"Deactivate the app."
type AppDeactivate {
    app: App
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
}

"Deletes an app."
type AppDelete {
    app: App
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
}

"Delete failed installation."
type AppDeleteFailedInstallation {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    appInstallation: AppInstallation
    errors: [AppError!]!
}

type AppError {
    "The error code."
    code: AppErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
}

"Represents app data."
type AppExtension implements Node {
    "JWT token used to authenticate by thridparty app extension."
    accessToken: String
    app: App!
    id: ID!
    "Label of the extension to show in the dashboard."
    label: String!
    "Place where given extension will be mounted."
    mount: AppExtensionMountEnum!
    "List of the app extension's permissions."
    permissions: [Permission!]!
    "Type of way how app extension will be opened."
    target: AppExtensionTargetEnum!
    "URL of a view where extension's iframe is placed."
    url: String!
}

type AppExtensionCountableConnection {
    edges: [AppExtensionCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AppExtensionCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AppExtension!
}

"Fetch and validate manifest."
type AppFetchManifest {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
    manifest: Manifest
}

"Install new app by using app manifest."
type AppInstall {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    appInstallation: AppInstallation
    errors: [AppError!]!
}

"Represents ongoing installation of app."
type AppInstallation implements Job & Node {
    appName: String!
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    id: ID!
    manifestUrl: String!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
}

type AppManifestExtension {
    "Label of the extension to show in the dashboard."
    label: String!
    "Place where given extension will be mounted."
    mount: AppExtensionMountEnum!
    "List of the app extension's permissions."
    permissions: [Permission!]!
    "Type of way how app extension will be opened."
    target: AppExtensionTargetEnum!
    "URL of a view where extension's iframe is placed."
    url: String!
}

"Retry failed installation of new app."
type AppRetryInstall {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    appInstallation: AppInstallation
    errors: [AppError!]!
}

"Represents token data."
type AppToken implements Node {
    "Last 4 characters of the token."
    authToken: String
    id: ID!
    "Name of the authenticated token."
    name: String
}

"Creates a new token."
type AppTokenCreate {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    appToken: AppToken
    "The newly created authentication token."
    authToken: String
    errors: [AppError!]!
}

"Deletes an authentication token assigned to app."
type AppTokenDelete {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    appToken: AppToken
    errors: [AppError!]!
}

"Verify provided app token."
type AppTokenVerify {
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
    "Determine if token is valid or not."
    valid: Boolean!
}

"Updates an existing app."
type AppUpdate {
    app: App
    appErrors: [AppError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AppError!]!
}

"Assigns storefront's navigation menus."
type AssignNavigation {
    errors: [MenuError!]!
    "Assigned navigation menu."
    menu: Menu
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"New in Saleor 3.1. Represents assigned attribute to variant with variant selection attached."
type AssignedVariantAttribute {
    "Attribute assigned to variant."
    attribute: Attribute!
    "Determines, whether assigned attribute is allowed for variant selection. Supported variant types for variant selection are: ['dropdown', 'boolean', 'swatch', 'numeric']"
    variantSelection: Boolean!
}

"Custom attribute of a product. Attributes can be assigned to products and variants at the product type level."
type Attribute implements Node & ObjectWithMetadata {
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean!
    "List of attribute's values."
    choices(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for attribute choices."
        filter: AttributeValueFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort attribute choices."
        sortBy: AttributeChoicesSortingInput
    ): AttributeValueCountableConnection
    "The entity type which can be used as a reference."
    entityType: AttributeEntityTypeEnum
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean!
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean!
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of an attribute displayed in the interface."
    name: String
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productTypes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductTypeCountableConnection!
    productVariantTypes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductTypeCountableConnection!
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int!
    "Returns translated attribute fields for the given language code."
    translation(
        "A language code to return the translation for attribute."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslation
    "The attribute type."
    type: AttributeTypeEnum
    "The unit of attribute values."
    unit: MeasurementUnitsEnum
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean!
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean!
    "Flag indicating that attribute has predefined choices."
    withChoices: Boolean!
}

"Deletes attributes."
type AttributeBulkDelete {
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were affected."
    count: Int!
    errors: [AttributeError!]!
}

type AttributeCountableConnection {
    edges: [AttributeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AttributeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Attribute!
}

"Creates an attribute."
type AttributeCreate {
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AttributeError!]!
}

"Deletes an attribute."
type AttributeDelete {
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AttributeError!]!
}

type AttributeError {
    "The error code."
    code: AttributeErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Reorder the values of an attribute."
type AttributeReorderValues {
    "Attribute from which values are reordered."
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AttributeError!]!
}

type AttributeTranslatableContent implements Node {
    "Custom attribute of a product."
    attribute: Attribute @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    id: ID!
    name: String!
    "Returns translated attribute fields for the given language code."
    translation(
        "A language code to return the translation for attribute."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslation
}

"Creates/updates translations for an attribute."
type AttributeTranslate {
    attribute: Attribute
    errors: [TranslationError!]!
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type AttributeTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates attribute."
type AttributeUpdate {
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AttributeError!]!
}

"Represents a value of an attribute."
type AttributeValue implements Node {
    "Represents the boolean value of the attribute value."
    boolean: Boolean
    "Represents the date value of the attribute value."
    date: Date
    "Represents the date time value of the attribute value."
    dateTime: DateTime
    "Represents file URL and content type (if attribute value is a file)."
    file: File
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "Name of a value displayed in the interface."
    name: String
    "The ID of the attribute reference."
    reference: ID
    "Represents the text (JSON) of the attribute value."
    richText: JSONString
    "Internal representation of a value (unique per attribute)."
    slug: String
    "Returns translated attribute value fields for the given language code."
    translation(
        "A language code to return the translation for attribute value."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslation
    "Represent value of the attribute value (e.g. color values for swatch attributes)."
    value: String
}

"Deletes values of attributes."
type AttributeValueBulkDelete {
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were affected."
    count: Int!
    errors: [AttributeError!]!
}

type AttributeValueCountableConnection {
    edges: [AttributeValueCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AttributeValueCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AttributeValue!
}

"Creates a value for an attribute."
type AttributeValueCreate {
    "The updated attribute."
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    attributeValue: AttributeValue
    errors: [AttributeError!]!
}

"Deletes a value of an attribute."
type AttributeValueDelete {
    "The updated attribute."
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    attributeValue: AttributeValue
    errors: [AttributeError!]!
}

type AttributeValueTranslatableContent implements Node {
    "Represents a value of an attribute."
    attributeValue: AttributeValue @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    id: ID!
    name: String!
    richText: JSONString
    "Returns translated attribute value fields for the given language code."
    translation(
        "A language code to return the translation for attribute value."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslation
}

"Creates/updates translations for an attribute value."
type AttributeValueTranslate {
    attributeValue: AttributeValue
    errors: [TranslationError!]!
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type AttributeValueTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    richText: JSONString
}

"Updates value of an attribute."
type AttributeValueUpdate {
    "The updated attribute."
    attribute: Attribute
    attributeErrors: [AttributeError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    attributeValue: AttributeValue
    errors: [AttributeError!]!
}

type BulkProductError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "List of channel IDs which causes the error."
    channels: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "Index of an input list item that caused the error."
    index: Int
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
    "List of warehouse IDs which causes the error."
    warehouses: [ID!]
}

type BulkStockError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "Index of an input list item that caused the error."
    index: Int
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
}

"Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront."
type Category implements Node & ObjectWithMetadata {
    "List of ancestors of the category."
    ancestors(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    "List of children of the category."
    children(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    description: JSONString
    "Description of the category (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    level: Int!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    parent: Category
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in the category."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated category fields for the given language code."
    translation(
        "A language code to return the translation for category."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslation
}

"Deletes categories."
type CategoryBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type CategoryCountableConnection {
    edges: [CategoryCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CategoryCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Category!
}

"Creates a new category."
type CategoryCreate {
    category: Category
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a category."
type CategoryDelete {
    category: Category
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type CategoryTranslatableContent implements Node {
    "Represents a single category of products."
    category: Category @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    description: JSONString
    "Description of the category (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    name: String!
    seoDescription: String
    seoTitle: String
    "Returns translated category fields for the given language code."
    translation(
        "A language code to return the translation for category."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslation
}

"Creates/updates translations for a category."
type CategoryTranslate {
    category: Category
    errors: [TranslationError!]!
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type CategoryTranslation implements Node {
    description: JSONString
    "Translated description of the product (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
    seoDescription: String
    seoTitle: String
}

"Updates a category."
type CategoryUpdate {
    category: Category
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents channel."
type Channel implements Node {
    currencyCode: String!
    "New in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided."
    defaultCountry: CountryDisplay!
    "Whether a channel has associated orders."
    hasOrders: Boolean!
    id: ID!
    isActive: Boolean!
    name: String!
    slug: String!
}

"Activate a channel."
type ChannelActivate {
    "Activated channel."
    channel: Channel
    channelErrors: [ChannelError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [ChannelError!]!
}

"Creates new channel."
type ChannelCreate {
    channel: Channel
    channelErrors: [ChannelError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [ChannelError!]!
}

"Deactivate a channel."
type ChannelDeactivate {
    "Deactivated channel."
    channel: Channel
    channelErrors: [ChannelError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [ChannelError!]!
}

"Delete a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed."
type ChannelDelete {
    channel: Channel
    channelErrors: [ChannelError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [ChannelError!]!
}

type ChannelError {
    "The error code."
    code: ChannelErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of shipping zone IDs which causes the error."
    shippingZones: [ID!]
}

"Update a channel."
type ChannelUpdate {
    channel: Channel
    channelErrors: [ChannelError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [ChannelError!]!
}

"Checkout object."
type Checkout implements Node & ObjectWithMetadata {
    "New in Saleor 3.1. Collection points that can be used for this order. Note: this feature is in a preview state and can be subject to changes at later point."
    availableCollectionPoints: [Warehouse!]!
    "List of available payment gateways."
    availablePaymentGateways: [PaymentGateway!]!
    "Shipping methods that can be used with this checkout."
    availableShippingMethods: [ShippingMethod]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `shippingMethods` instead.")
    billingAddress: Address
    channel: Channel!
    created: DateTime!
    "New in Saleor 3.1. The delivery method selected for this checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    deliveryMethod: DeliveryMethod
    discount: Money
    discountName: String
    "Email of a customer."
    email: String
    "List of gift cards associated with this checkout."
    giftCards: [GiftCard]
    id: ID!
    "Returns True, if checkout requires shipping."
    isShippingRequired: Boolean!
    "Checkout language code."
    languageCode: LanguageCodeEnum!
    lastChange: DateTime!
    "A list of checkout lines, each containing information about an item in the checkout."
    lines: [CheckoutLine]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    note: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "The number of items purchased."
    quantity: Int!
    shippingAddress: Address
    "The shipping method related with checkout."
    shippingMethod: ShippingMethod @deprecated(reason: "This field will be removed in Saleor 4.0. Use `deliveryMethod` instead.")
    "Shipping methods that can be used with this checkout."
    shippingMethods: [ShippingMethod]!
    "The price of the shipping, with all the taxes included."
    shippingPrice: TaxedMoney
    "New in Saleor 3.1. Date when oldest stock reservation for this checkout  expires or null if no stock is reserved."
    stockReservationExpires: DateTime
    "The price of the checkout before shipping, with taxes included."
    subtotalPrice: TaxedMoney
    "The checkout's token."
    token: UUID!
    "The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included."
    totalPrice: TaxedMoney
    translatedDiscountName: String
    user: User
    voucherCode: String
}

"Adds a gift card or a voucher to a checkout."
type CheckoutAddPromoCode {
    "The checkout with the added gift card or voucher."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Update billing address in the existing checkout."
type CheckoutBillingAddressUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation."
type CheckoutComplete {
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Confirmation data used to process additional authorization steps."
    confirmationData: JSONString
    "Set to true if payment needs to be confirmed before checkout is complete."
    confirmationNeeded: Boolean!
    errors: [CheckoutError!]!
    "Placed order."
    order: Order
}

type CheckoutCountableConnection {
    edges: [CheckoutCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CheckoutCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Checkout!
}

"Create a new checkout."
type CheckoutCreate {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Whether the checkout was created or the current active one was returned. Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout."
    created: Boolean @deprecated(reason: "This field will be removed in Saleor 4.0. Always returns `True`.")
    errors: [CheckoutError!]!
}

"Sets the customer as the owner of the checkout."
type CheckoutCustomerAttach {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Removes the user assigned as the owner of the checkout."
type CheckoutCustomerDetach {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"New in Saleor 3.1. Updates the delivery method (shipping method or pick up point) of the checkout. Note: this feature is in a preview state and can be subject to changes at later point."
type CheckoutDeliveryMethodUpdate {
    "An updated checkout."
    checkout: Checkout
    errors: [CheckoutError!]!
}

"Updates email address in the existing checkout object."
type CheckoutEmailUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

type CheckoutError {
    "A type of address that causes the error."
    addressType: AddressTypeEnum
    "The error code."
    code: CheckoutErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "List of line Ids which cause the error."
    lines: [ID!]
    "The error message."
    message: String
    "List of varint IDs which causes the error."
    variants: [ID!]
}

"Update language code in the existing checkout."
type CheckoutLanguageCodeUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Represents an item in the checkout."
type CheckoutLine implements Node {
    id: ID!
    quantity: Int!
    "Indicates whether the item need to be delivered."
    requiresShipping: Boolean
    "The sum of the checkout line price, taxes and discounts."
    totalPrice: TaxedMoney
    variant: ProductVariant!
}

type CheckoutLineCountableConnection {
    edges: [CheckoutLineCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CheckoutLineCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CheckoutLine!
}

"Deletes a CheckoutLine."
type CheckoutLineDelete {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased."
type CheckoutLinesAdd {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Deletes checkout lines."
type CheckoutLinesDelete {
    "An updated checkout."
    checkout: Checkout
    errors: [CheckoutError!]!
}

"Updates checkout line in the existing checkout."
type CheckoutLinesUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Create a new payment for given checkout."
type CheckoutPaymentCreate {
    "Related checkout object."
    checkout: Checkout
    errors: [PaymentError!]!
    "A newly created payment."
    payment: Payment
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Remove a gift card or a voucher from a checkout."
type CheckoutRemovePromoCode {
    "The checkout with the removed gift card or voucher."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Update shipping address in the existing checkout."
type CheckoutShippingAddressUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

"Updates the shipping method of the checkout."
type CheckoutShippingMethodUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CheckoutError!]!
}

type ChoiceValue {
    raw: String
    verbose: String
}

"Represents a collection of products."
type Collection implements Node & ObjectWithMetadata {
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    "Channel given to retrieve this collection. Also used by federation gateway to resolve this object in a federated query."
    channel: String
    "List of channels in which the collection is available."
    channelListings: [CollectionChannelListing!]
    description: JSONString
    "Description of the collection (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in this collection."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for products."
        filter: ProductFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort products."
        sortBy: ProductOrder
    ): ProductCountableConnection
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated collection fields for the given language code."
    translation(
        "A language code to return the translation for collection."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslation
}

"Adds products to a collection."
type CollectionAddProducts {
    "Collection to which products will be added."
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

"Deletes collections."
type CollectionBulkDelete {
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were affected."
    count: Int!
    errors: [CollectionError!]!
}

"Represents collection channel listing."
type CollectionChannelListing implements Node {
    channel: Channel!
    id: ID!
    isPublished: Boolean!
    publicationDate: Date
}

type CollectionChannelListingError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "List of channels IDs which causes the error."
    channels: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
}

"Manage collection's availability in channels."
type CollectionChannelListingUpdate {
    "An updated collection instance."
    collection: Collection
    collectionChannelListingErrors: [CollectionChannelListingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionChannelListingError!]!
}

type CollectionCountableConnection {
    edges: [CollectionCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CollectionCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Collection!
}

"Creates a new collection."
type CollectionCreate {
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

"Deletes a collection."
type CollectionDelete {
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

type CollectionError {
    "The error code."
    code: CollectionErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of products IDs which causes the error."
    products: [ID!]
}

"Remove products from a collection."
type CollectionRemoveProducts {
    "Collection from which products will be removed."
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

"Reorder the products of a collection."
type CollectionReorderProducts {
    "Collection from which products are reordered."
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

type CollectionTranslatableContent implements Node {
    "Represents a collection of products."
    collection: Collection @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    description: JSONString
    "Description of the collection (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    name: String!
    seoDescription: String
    seoTitle: String
    "Returns translated collection fields for the given language code."
    translation(
        "A language code to return the translation for collection."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslation
}

"Creates/updates translations for a collection."
type CollectionTranslate {
    collection: Collection
    errors: [TranslationError!]!
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type CollectionTranslation implements Node {
    description: JSONString
    "Translated description of the product (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
    seoDescription: String
    seoTitle: String
}

"Updates a collection."
type CollectionUpdate {
    collection: Collection
    collectionErrors: [CollectionError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [CollectionError!]!
}

"Stores information about a single configuration field."
type ConfigurationItem {
    "Help text for the field."
    helpText: String
    "Label for the field."
    label: String
    "Name of the field."
    name: String!
    "Type of the field."
    type: ConfigurationTypeFieldEnum
    "Current value of the field."
    value: String
}

"Confirm user account with token sent by email during registration."
type ConfirmAccount {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "An activated user account."
    user: User
}

"Confirm the email change of the logged-in user."
type ConfirmEmailChange {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "A user instance with a new email."
    user: User
}

type CountryDisplay {
    "Country code."
    code: String!
    "Country name."
    country: String!
    "Country tax."
    vat: VAT
}

"Create JWT token."
type CreateToken {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "CSRF token required to re-generate access token."
    csrfToken: String
    errors: [AccountError!]!
    "JWT refresh token, required to re-generate access token."
    refreshToken: String
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

type CreditCard {
    "Card brand."
    brand: String!
    "Two-digit number representing the card’s expiration month."
    expMonth: Int
    "Four-digit number representing the card’s expiration year."
    expYear: Int
    "First 4 digits of the card number."
    firstDigits: String
    "Last 4 digits of the card number."
    lastDigits: String!
}

"Deletes customers."
type CustomerBulkDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were affected."
    count: Int!
    errors: [AccountError!]!
}

"Creates a new customer."
type CustomerCreate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    user: User
}

"Deletes a customer."
type CustomerDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    user: User
}

"History log of the customer."
type CustomerEvent implements Node {
    "App that performed the action."
    app: App
    "Number of objects concerned by the event."
    count: Int
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    id: ID!
    "Content of the event."
    message: String
    "The concerned order."
    order: Order
    "The concerned order line."
    orderLine: OrderLine
    "Customer event type."
    type: CustomerEventsEnum
    "User who performed the action."
    user: User
}

"Updates an existing customer."
type CustomerUpdate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    user: User
}

"Deactivate all JWT tokens of the currently authenticated user."
type DeactivateAllUserTokens {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
}

"Delete metadata of an object."
type DeleteMetadata {
    errors: [MetadataError!]!
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Delete object's private metadata."
type DeletePrivateMetadata {
    errors: [MetadataError!]!
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type DigitalContent implements Node & ObjectWithMetadata {
    automaticFulfillment: Boolean!
    contentFile: String!
    id: ID!
    maxDownloads: Int
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Product variant assigned to digital content."
    productVariant: ProductVariant!
    urlValidDays: Int
    "List of URLs for the digital variant."
    urls: [DigitalContentUrl]
    useDefaultSettings: Boolean!
}

type DigitalContentCountableConnection {
    edges: [DigitalContentCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type DigitalContentCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DigitalContent!
}

"Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type DigitalContentCreate {
    content: DigitalContent
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    variant: ProductVariant
}

"Remove digital content assigned to given variant."
type DigitalContentDelete {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    variant: ProductVariant
}

"Update digital content."
type DigitalContentUpdate {
    content: DigitalContent
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    variant: ProductVariant
}

type DigitalContentUrl implements Node {
    content: DigitalContent!
    created: DateTime!
    downloadNum: Int!
    id: ID!
    "UUID of digital content."
    token: UUID!
    "URL for digital content."
    url: String
}

"Generate new URL to digital content."
type DigitalContentUrlCreate {
    digitalContentUrl: DigitalContentUrl
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type DiscountError {
    "List of channels IDs which causes the error."
    channels: [ID!]
    "The error code."
    code: DiscountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of products IDs which causes the error."
    products: [ID!]
}

"Represents shop's domain."
type Domain {
    "The host name of the domain."
    host: String!
    "Inform if SSL is enabled."
    sslEnabled: Boolean!
    "Shop's absolute URL."
    url: String!
}

"Deletes draft orders."
type DraftOrderBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [OrderError!]!
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Completes creating an order."
type DraftOrderComplete {
    errors: [OrderError!]!
    "Completed order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Creates a new draft order."
type DraftOrderCreate {
    errors: [OrderError!]!
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a draft order."
type DraftOrderDelete {
    errors: [OrderError!]!
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes order lines."
type DraftOrderLinesBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [OrderError!]!
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates a draft order."
type DraftOrderUpdate {
    errors: [OrderError!]!
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Event delivery."
type EventDelivery implements Node {
    "Event delivery attempts."
    attempts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Event delivery sorter"
        sortBy: EventDeliveryAttemptSortingInput
    ): EventDeliveryAttemptCountableConnection
    createdAt: DateTime!
    "Webhook event type."
    eventType: WebhookEventTypeEnum!
    id: ID!
    "Event payload."
    payload: String
    "Event delivery status."
    status: EventDeliveryStatusEnum!
}

"Event delivery attempts."
type EventDeliveryAttempt implements Node {
    "Event delivery creation date and time."
    createdAt: DateTime!
    duration: Float
    id: ID!
    requestHeaders: String
    response: String
    responseHeaders: String
    "Event delivery status."
    status: EventDeliveryStatusEnum!
    taskId: String
}

type EventDeliveryAttemptCountableConnection {
    edges: [EventDeliveryAttemptCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type EventDeliveryAttemptCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: EventDeliveryAttempt!
}

type EventDeliveryCountableConnection {
    edges: [EventDeliveryCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type EventDeliveryCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: EventDelivery!
}

"Retries event delivery."
type EventDeliveryRetry {
    "Event delivery."
    delivery: EventDelivery
    errors: [WebhookError!]!
}

type ExportError {
    "The error code."
    code: ExportErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"History log of export file."
type ExportEvent implements Node {
    "App which performed the action."
    app: App
    "Date when event happened at in ISO 8601 format."
    date: DateTime!
    "The ID of the object."
    id: ID!
    "Content of the event."
    message: String!
    "Export event type."
    type: ExportEventsEnum!
    "User who performed the action."
    user: User
}

"Represents a job data of exported file."
type ExportFile implements Job & Node {
    app: App
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "List of events associated with the export."
    events: [ExportEvent!]
    id: ID!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
    "The URL of field to download."
    url: String
    user: User
}

type ExportFileCountableConnection {
    edges: [ExportFileCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ExportFileCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ExportFile!
}

"New in Saleor 3.1. Export gift cards to csv file. Note: this feature is in a preview state and can be subject to changes at later point."
type ExportGiftCards {
    errors: [ExportError!]!
    "The newly created export file job which is responsible for export data."
    exportFile: ExportFile
}

"Export products to csv file."
type ExportProducts {
    errors: [ExportError!]!
    exportErrors: [ExportError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The newly created export file job which is responsible for export data."
    exportFile: ExportFile
}

type ExternalAuthentication {
    "ID of external authentication plugin."
    id: String!
    "Name of external authentication plugin."
    name: String
}

"Prepare external authentication url for user by custom plugin."
type ExternalAuthenticationUrl {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The data returned by authentication plugin."
    authenticationData: JSONString
    errors: [AccountError!]!
}

"Logout user by custom plugin."
type ExternalLogout {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "The data returned by authentication plugin."
    logoutData: JSONString
}

type ExternalNotificationError {
    "The error code."
    code: ExternalNotificationErrorCodes!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"New in Saleor 3.1. Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload."
type ExternalNotificationTrigger {
    errors: [ExternalNotificationError!]!
}

"Obtain external access tokens for user by custom plugin."
type ExternalObtainAccessTokens {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "CSRF token required to re-generate external access token."
    csrfToken: String
    errors: [AccountError!]!
    "The refresh token, required to re-generate external access token."
    refreshToken: String
    "The token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

"Refresh user's access by custom plugin."
type ExternalRefresh {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "CSRF token required to re-generate external access token."
    csrfToken: String
    errors: [AccountError!]!
    "The refresh token, required to re-generate external access token."
    refreshToken: String
    "The token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

"Verify external authentication data by plugin."
type ExternalVerify {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "Determine if authentication data is valid or not."
    isValid: Boolean!
    "User assigned to data."
    user: User
    "External data."
    verifyData: JSONString
}

type File {
    "Content type of the file."
    contentType: String
    "The URL of the file."
    url: String!
}

"Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type FileUpload {
    errors: [UploadError!]!
    uploadErrors: [UploadError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    uploadedFile: File
}

"Represents order fulfillment."
type Fulfillment implements Node & ObjectWithMetadata {
    created: DateTime!
    fulfillmentOrder: Int!
    id: ID!
    "List of lines for the fulfillment."
    lines: [FulfillmentLine]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    status: FulfillmentStatus!
    "User-friendly fulfillment status."
    statusDisplay: String
    trackingNumber: String!
    "Warehouse from fulfillment was fulfilled."
    warehouse: Warehouse
}

"New in Saleor 3.1. Approve existing fulfillment."
type FulfillmentApprove {
    errors: [OrderError!]!
    "An approved fulfillment."
    fulfillment: Fulfillment
    "Order which fulfillment was approved."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Cancels existing fulfillment and optionally restocks items."
type FulfillmentCancel {
    errors: [OrderError!]!
    "A canceled fulfillment."
    fulfillment: Fulfillment
    "Order which fulfillment was cancelled."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents line of the fulfillment."
type FulfillmentLine implements Node {
    id: ID!
    orderLine: OrderLine
    quantity: Int!
}

"Refund products."
type FulfillmentRefundProducts {
    errors: [OrderError!]!
    "A refunded fulfillment."
    fulfillment: Fulfillment
    "Order which fulfillment was refunded."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Return products."
type FulfillmentReturnProducts {
    errors: [OrderError!]!
    "Order which fulfillment was returned."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "A replace fulfillment."
    replaceFulfillment: Fulfillment
    "A draft order which was created for products with replace flag."
    replaceOrder: Order
    "A return fulfillment."
    returnFulfillment: Fulfillment
}

"Updates a fulfillment for an order."
type FulfillmentUpdateTracking {
    errors: [OrderError!]!
    "A fulfillment with updated tracking."
    fulfillment: Fulfillment
    "Order for which fulfillment was updated."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Payment gateway client configuration key and value pair."
type GatewayConfigLine {
    "Gateway config key."
    field: String!
    "Gateway config value for key."
    value: String
}

"A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes."
type GiftCard implements Node & ObjectWithMetadata {
    "New in Saleor 3.1. App which created the gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    app: App
    "New in Saleor 3.1. Slug of the channel where the gift card was bought. Note: this feature is in a preview state and can be subject to changes at later point."
    boughtInChannel: String
    "Gift card code. Can be fetched by staff member with manage gift card permission when gift card wasn't used yet and by the gift card owner."
    code: String!
    created: DateTime!
    "New in Saleor 3.1. The user who bought or issued a gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    createdBy: User
    "New in Saleor 3.1. Email address of the user who bought or issued gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    createdByEmail: String
    currentBalance: Money
    "Code in format which allows displaying in a user interface."
    displayCode: String!
    "End date of gift card."
    endDate: DateTime @deprecated(reason: "This field will be removed in Saleor 4.0. Use `expiryDate` field instead.")
    "New in Saleor 3.1. List of events associated with the gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    events(
        "Filtering options for gift card events."
        filter: GiftCardEventFilterInput
    ): [GiftCardEvent!]!
    expiryDate: Date
    id: ID!
    initialBalance: Money
    isActive: Boolean!
    "Last 4 characters of gift card code."
    last4CodeChars: String!
    lastUsedOn: DateTime
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "New in Saleor 3.1. Related gift card product. Note: this feature is in a preview state and can be subject to changes at later point."
    product: Product
    "Start date of gift card."
    startDate: DateTime @deprecated(reason: "This field will be removed in Saleor 4.0.")
    "New in Saleor 3.1. The gift card tag. Note: this feature is in a preview state and can be subject to changes at later point."
    tags: [GiftCardTag!]!
    "New in Saleor 3.1. The customer who used a gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    usedBy: User
    "New in Saleor 3.1. Email address of the customer who used a gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    usedByEmail: String
    "The customer who bought a gift card."
    user: User @deprecated(reason: "This field will be removed in Saleor 4.0. Use `createdBy` field instead.")
}

"Activate a gift card."
type GiftCardActivate {
    errors: [GiftCardError!]!
    "Activated gift card."
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"New in Saleor 3.1. Adds note to the gift card. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardAddNote {
    errors: [GiftCardError!]!
    "Gift card note created."
    event: GiftCardEvent
    "Gift card with the note added."
    giftCard: GiftCard
}

"New in Saleor 3.1. Activate gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardBulkActivate {
    "Returns how many objects were affected."
    count: Int!
    errors: [GiftCardError!]!
}

"New in Saleor 3.1. Create gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardBulkCreate {
    "Returns how many objects were created."
    count: Int!
    errors: [GiftCardError!]!
    "List of created gift cards."
    giftCards: [GiftCard!]!
}

"New in Saleor 3.1. Deactivate gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardBulkDeactivate {
    "Returns how many objects were affected."
    count: Int!
    errors: [GiftCardError!]!
}

"New in Saleor 3.1. Delete gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [GiftCardError!]!
}

type GiftCardCountableConnection {
    edges: [GiftCardCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GiftCardCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GiftCard!
}

"Creates a new gift card."
type GiftCardCreate {
    errors: [GiftCardError!]!
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deactivate a gift card."
type GiftCardDeactivate {
    errors: [GiftCardError!]!
    "Deactivated gift card."
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"New in Saleor 3.1. Delete gift card. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardDelete {
    errors: [GiftCardError!]!
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type GiftCardError {
    "The error code."
    code: GiftCardErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of tag values that cause the error."
    tags: [String!]
}

"New in Saleor 3.1. History log of the gift card. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardEvent implements Node {
    "App that performed the action."
    app: App
    "The gift card balance."
    balance: GiftCardEventBalance
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "Email of the customer."
    email: String
    "The gift card expiry date."
    expiryDate: Date
    id: ID!
    "Content of the event."
    message: String
    "Previous gift card expiry date."
    oldExpiryDate: Date
    "The list of old gift card tags."
    oldTags: [String!]
    "The order ID where gift card was used or bought."
    orderId: ID
    "User-friendly number of an order where gift card was used or bought."
    orderNumber: String
    "The list of gift card tags."
    tags: [String!]
    "Gift card event type."
    type: GiftCardEventsEnum
    "User who performed the action."
    user: User
}

type GiftCardEventBalance {
    "Current balance of the gift card."
    currentBalance: Money!
    "Initial balance of the gift card."
    initialBalance: Money
    "Previous current balance of the gift card."
    oldCurrentBalance: Money
    "Previous initial balance of the gift card."
    oldInitialBalance: Money
}

"New in Saleor 3.1. Resend a gift card. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardResend {
    errors: [GiftCardError!]!
    "Gift card which has been sent."
    giftCard: GiftCard
}

"Gift card related settings from site settings."
type GiftCardSettings {
    "The gift card expiry period settings."
    expiryPeriod: TimePeriod
    "The gift card expiry type settings."
    expiryType: GiftCardSettingsExpiryTypeEnum!
}

type GiftCardSettingsError {
    "The error code."
    code: GiftCardSettingsErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update gift card settings."
type GiftCardSettingsUpdate {
    errors: [GiftCardSettingsError!]!
    "Gift card settings."
    giftCardSettings: GiftCardSettings
}

"New in Saleor 3.1. The gift card tag. Note: this feature is in a preview state and can be subject to changes at later point."
type GiftCardTag implements Node {
    id: ID!
    name: String!
}

type GiftCardTagCountableConnection {
    edges: [GiftCardTagCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GiftCardTagCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GiftCardTag!
}

"Update a gift card."
type GiftCardUpdate {
    errors: [GiftCardError!]!
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents permission group data."
type Group implements Node {
    id: ID!
    name: String!
    "List of group permissions"
    permissions: [Permission]
    "True, if the currently authenticated user has rights to manage a group."
    userCanManage: Boolean!
    "List of group users"
    users: [User]
}

type GroupCountableConnection {
    edges: [GroupCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GroupCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Group!
}

"Represents an image."
type Image {
    "Alt text for an image."
    alt: String
    "The URL of the image."
    url: String!
}

"Represents an Invoice."
type Invoice implements Job & Node & ObjectWithMetadata {
    createdAt: DateTime!
    externalUrl: String
    "The ID of the object."
    id: ID!
    message: String
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    number: String
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Job status."
    status: JobStatusEnum!
    updatedAt: DateTime!
    "URL to download an invoice."
    url: String
}

"Creates a ready to send invoice."
type InvoiceCreate {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes an invoice."
type InvoiceDelete {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type InvoiceError {
    "The error code."
    code: InvoiceErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Request an invoice for the order using plugin."
type InvoiceRequest {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Order related to an invoice."
    order: Order
}

"Requests deletion of an invoice."
type InvoiceRequestDelete {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Send an invoice notification to the customer."
type InvoiceSendNotification {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates an invoice."
type InvoiceUpdate {
    errors: [InvoiceError!]!
    invoice: Invoice
    invoiceErrors: [InvoiceError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type LanguageDisplay {
    "ISO 639 representation of the language name."
    code: LanguageCodeEnum!
    "Full name of the language."
    language: String!
}

type LimitInfo {
    "Defines the allowed maximum resource usage, null means unlimited."
    allowedUsage: Limits!
    "Defines the current resource usage."
    currentUsage: Limits!
}

type Limits {
    channels: Int
    orders: Int
    productVariants: Int
    staffUsers: Int
    warehouses: Int
}

"The manifest definition."
type Manifest {
    about: String
    appUrl: String
    configurationUrl: String
    dataPrivacy: String
    dataPrivacyUrl: String
    extensions: [AppManifestExtension!]!
    homepageUrl: String
    identifier: String!
    name: String!
    permissions: [Permission]
    supportUrl: String
    tokenTargetUrl: String
    version: String!
}

type Margin {
    start: Int
    stop: Int
}

"Represents a single menu - an object that is used to help navigate through the store."
type Menu implements Node & ObjectWithMetadata {
    id: ID!
    items: [MenuItem]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    slug: String!
}

"Deletes menus."
type MenuBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [MenuError!]!
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MenuCountableConnection {
    edges: [MenuCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type MenuCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Menu!
}

"Creates a new Menu."
type MenuCreate {
    errors: [MenuError!]!
    menu: Menu
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a menu."
type MenuDelete {
    errors: [MenuError!]!
    menu: Menu
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MenuError {
    "The error code."
    code: MenuErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Represents a single item of the related menu. Can store categories, collection or pages."
type MenuItem implements Node & ObjectWithMetadata {
    category: Category
    children: [MenuItem]
    collection: Collection
    id: ID!
    level: Int!
    menu: Menu!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    page: Page
    parent: MenuItem
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Returns translated menu item fields for the given language code."
    translation(
        "A language code to return the translation for menu item."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslation
    "URL to the menu item."
    url: String
}

"Deletes menu items."
type MenuItemBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [MenuError!]!
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MenuItemCountableConnection {
    edges: [MenuItemCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type MenuItemCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MenuItem!
}

"Creates a new menu item."
type MenuItemCreate {
    errors: [MenuError!]!
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    menuItem: MenuItem
}

"Deletes a menu item."
type MenuItemDelete {
    errors: [MenuError!]!
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    menuItem: MenuItem
}

"Moves items of menus."
type MenuItemMove {
    errors: [MenuError!]!
    "Assigned menu to move within."
    menu: Menu
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MenuItemTranslatableContent implements Node {
    id: ID!
    "Represents a single item of the related menu. Can store categories, collection or pages."
    menuItem: MenuItem @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    name: String!
    "Returns translated menu item fields for the given language code."
    translation(
        "A language code to return the translation for menu item."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslation
}

"Creates/updates translations for a menu item."
type MenuItemTranslate {
    errors: [TranslationError!]!
    menuItem: MenuItem
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MenuItemTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates a menu item."
type MenuItemUpdate {
    errors: [MenuError!]!
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    menuItem: MenuItem
}

"Updates a menu."
type MenuUpdate {
    errors: [MenuError!]!
    menu: Menu
    menuErrors: [MenuError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type MetadataError {
    "The error code."
    code: MetadataErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

type MetadataItem {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

"Represents amount of money in specific currency."
type Money {
    "Amount of money."
    amount: Float!
    "Currency code."
    currency: String!
}

"Represents a range of amounts of money."
type MoneyRange {
    "Lower bound of a price range."
    start: Money
    "Upper bound of a price range."
    stop: Money
}

type Mutation {
    "Create a new address for the customer."
    accountAddressCreate(
        "Fields required to create address."
        input: AddressInput!,
        "A type of address. If provided, the new address will be automatically assigned as the customer's default address of that type."
        type: AddressTypeEnum
    ): AccountAddressCreate
    "Delete an address of the logged-in user."
    accountAddressDelete(
        "ID of the address to delete."
        id: ID!
    ): AccountAddressDelete
    "Updates an address of the logged-in user."
    accountAddressUpdate(
        "ID of the address to update."
        id: ID!,
        "Fields required to update the address."
        input: AddressInput!
    ): AccountAddressUpdate
    "Remove user account."
    accountDelete(
        "A one-time token required to remove account. Sent by email using AccountRequestDeletion mutation."
        token: String!
    ): AccountDelete
    "Register a new user."
    accountRegister(
        "Fields required to create a user."
        input: AccountRegisterInput!
    ): AccountRegister
    "Sends an email with the account removal link for the logged-in user."
    accountRequestDeletion(
        "Slug of a channel which will be used to notify users. Optional when only one channel exists."
        channel: String,
        "URL of a view where users should be redirected to delete their account. URL in RFC 1808 format."
        redirectUrl: String!
    ): AccountRequestDeletion
    "Sets a default address for the authenticated user."
    accountSetDefaultAddress(
        "ID of the address to set as default."
        id: ID!,
        "The type of address."
        type: AddressTypeEnum!
    ): AccountSetDefaultAddress
    "Updates the account of the logged-in user."
    accountUpdate(
        "Fields required to update the account of the logged-in user."
        input: AccountInput!
    ): AccountUpdate
    "Creates user address."
    addressCreate(
        "Fields required to create address."
        input: AddressInput!,
        "ID of a user to create address for."
        userId: ID!
    ): AddressCreate
    "Deletes an address."
    addressDelete(
        "ID of the address to delete."
        id: ID!
    ): AddressDelete
    "Sets a default address for the given user."
    addressSetDefault(
        "ID of the address."
        addressId: ID!,
        "The type of address."
        type: AddressTypeEnum!,
        "ID of the user to change the address for."
        userId: ID!
    ): AddressSetDefault
    "Updates an address."
    addressUpdate(
        "ID of the address to update."
        id: ID!,
        "Fields required to update the address."
        input: AddressInput!
    ): AddressUpdate
    "Activate the app."
    appActivate(
        "ID of app to activate."
        id: ID!
    ): AppActivate
    "Creates a new app."
    appCreate(
        "Fields required to create a new app."
        input: AppInput!
    ): AppCreate
    "Deactivate the app."
    appDeactivate(
        "ID of app to deactivate."
        id: ID!
    ): AppDeactivate
    "Deletes an app."
    appDelete(
        "ID of an app to delete."
        id: ID!
    ): AppDelete
    "Delete failed installation."
    appDeleteFailedInstallation(
        "ID of failed installation to delete."
        id: ID!
    ): AppDeleteFailedInstallation
    "Fetch and validate manifest."
    appFetchManifest(manifestUrl: String!): AppFetchManifest
    "Install new app by using app manifest."
    appInstall(
        "Fields required to install a new app."
        input: AppInstallInput!
    ): AppInstall
    "Retry failed installation of new app."
    appRetryInstall(
        "Determine if app will be set active or not."
        activateAfterInstallation: Boolean,
        "ID of failed installation."
        id: ID!
    ): AppRetryInstall
    "Creates a new token."
    appTokenCreate(
        "Fields required to create a new auth token."
        input: AppTokenInput!
    ): AppTokenCreate
    "Deletes an authentication token assigned to app."
    appTokenDelete(
        "ID of an auth token to delete."
        id: ID!
    ): AppTokenDelete
    "Verify provided app token."
    appTokenVerify(
        "App token to verify."
        token: String!
    ): AppTokenVerify
    "Updates an existing app."
    appUpdate(
        "ID of an app to update."
        id: ID!,
        "Fields required to update an existing app."
        input: AppInput!
    ): AppUpdate
    "Assigns storefront's navigation menus."
    assignNavigation(
        "ID of the menu."
        menu: ID,
        "Type of the navigation bar to assign the menu to."
        navigationType: NavigationType!
    ): AssignNavigation
    "Add shipping zone to given warehouse."
    assignWarehouseShippingZone(
        "ID of a warehouse to update."
        id: ID!,
        "List of shipping zone IDs."
        shippingZoneIds: [ID!]!
    ): WarehouseShippingZoneAssign
    "Deletes attributes."
    attributeBulkDelete(
        "List of attribute IDs to delete."
        ids: [ID]!
    ): AttributeBulkDelete
    "Creates an attribute."
    attributeCreate(
        "Fields required to create an attribute."
        input: AttributeCreateInput!
    ): AttributeCreate
    "Deletes an attribute."
    attributeDelete(
        "ID of an attribute to delete."
        id: ID!
    ): AttributeDelete
    "Reorder the values of an attribute."
    attributeReorderValues(
        "ID of an attribute."
        attributeId: ID!,
        "The list of reordering operations for given attribute values."
        moves: [ReorderInput]!
    ): AttributeReorderValues
    "Creates/updates translations for an attribute."
    attributeTranslate(
        "Attribute ID or AttributeTranslatableContent ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslate
    "Updates attribute."
    attributeUpdate(
        "ID of an attribute to update."
        id: ID!,
        "Fields required to update an attribute."
        input: AttributeUpdateInput!
    ): AttributeUpdate
    "Deletes values of attributes."
    attributeValueBulkDelete(
        "List of attribute value IDs to delete."
        ids: [ID]!
    ): AttributeValueBulkDelete
    "Creates a value for an attribute."
    attributeValueCreate(
        "Attribute to which value will be assigned."
        attribute: ID!,
        "Fields required to create an AttributeValue."
        input: AttributeValueCreateInput!
    ): AttributeValueCreate
    "Deletes a value of an attribute."
    attributeValueDelete(
        "ID of a value to delete."
        id: ID!
    ): AttributeValueDelete
    "Creates/updates translations for an attribute value."
    attributeValueTranslate(
        "AttributeValue ID or AttributeValueTranslatableContent ID."
        id: ID!,
        input: AttributeValueTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslate
    "Updates value of an attribute."
    attributeValueUpdate(
        "ID of an AttributeValue to update."
        id: ID!,
        "Fields required to update an AttributeValue."
        input: AttributeValueUpdateInput!
    ): AttributeValueUpdate
    "Deletes categories."
    categoryBulkDelete(
        "List of category IDs to delete."
        ids: [ID]!
    ): CategoryBulkDelete
    "Creates a new category."
    categoryCreate(
        "Fields required to create a category."
        input: CategoryInput!,
        "ID of the parent category. If empty, category will be top level category."
        parent: ID
    ): CategoryCreate
    "Deletes a category."
    categoryDelete(
        "ID of a category to delete."
        id: ID!
    ): CategoryDelete
    "Creates/updates translations for a category."
    categoryTranslate(
        "Category ID or CategoryTranslatableContent ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslate
    "Updates a category."
    categoryUpdate(
        "ID of a category to update."
        id: ID!,
        "Fields required to update a category."
        input: CategoryInput!
    ): CategoryUpdate
    "Activate a channel."
    channelActivate(
        "ID of the channel to activate."
        id: ID!
    ): ChannelActivate
    "Creates new channel."
    channelCreate(
        "Fields required to create channel."
        input: ChannelCreateInput!
    ): ChannelCreate
    "Deactivate a channel."
    channelDeactivate(
        "ID of the channel to deactivate."
        id: ID!
    ): ChannelDeactivate
    "Delete a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed."
    channelDelete(
        "ID of a channel to delete."
        id: ID!,
        "Fields required to delete a channel."
        input: ChannelDeleteInput
    ): ChannelDelete
    "Update a channel."
    channelUpdate(
        "ID of a channel to update."
        id: ID!,
        "Fields required to update a channel."
        input: ChannelUpdateInput!
    ): ChannelUpdate
    "Adds a gift card or a voucher to a checkout."
    checkoutAddPromoCode(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Gift card code or voucher code."
        promoCode: String!,
        "Checkout token."
        token: UUID
    ): CheckoutAddPromoCode
    "Update billing address in the existing checkout."
    checkoutBillingAddressUpdate(
        "The billing address of the checkout."
        billingAddress: AddressInput!,
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutBillingAddressUpdate
    "Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation."
    checkoutComplete(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Client-side generated data required to finalize the payment."
        paymentData: JSONString,
        "URL of a view where users should be redirected to see the order details. URL in RFC 1808 format."
        redirectUrl: String,
        """

        Determines whether to store the payment source for future usage.

        DEPRECATED: this field will be removed in Saleor 4.0. Use checkoutPaymentCreate for this action.
        """
        storeSource: Boolean,
        "Checkout token."
        token: UUID
    ): CheckoutComplete
    "Create a new checkout."
    checkoutCreate(
        "Fields required to create checkout."
        input: CheckoutCreateInput!
    ): CheckoutCreate
    "Sets the customer as the owner of the checkout."
    checkoutCustomerAttach(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "ID of customer to attach to checkout. Can be used to attach customer to checkout by staff or app. Requires IMPERSONATE_USER permission."
        customerId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutCustomerAttach
    "Removes the user assigned as the owner of the checkout."
    checkoutCustomerDetach(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutCustomerDetach
    "New in Saleor 3.1. Updates the delivery method (shipping method or pick up point) of the checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    checkoutDeliveryMethodUpdate(
        "Delivery Method ID (`Warehouse` ID or `ShippingMethod` ID)."
        deliveryMethodId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutDeliveryMethodUpdate
    "Updates email address in the existing checkout object."
    checkoutEmailUpdate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "email."
        email: String!,
        "Checkout token."
        token: UUID
    ): CheckoutEmailUpdate
    "Update language code in the existing checkout."
    checkoutLanguageCodeUpdate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "New language code."
        languageCode: LanguageCodeEnum!,
        "Checkout token."
        token: UUID
    ): CheckoutLanguageCodeUpdate
    "Deletes a CheckoutLine."
    checkoutLineDelete(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "ID of the checkout line to delete."
        lineId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutLineDelete @deprecated(reason: "DEPRECATED: Will be removed in Saleor 4.0. Use `checkoutLinesDelete` instead.")
    "Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased."
    checkoutLinesAdd(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "A list of checkout lines, each containing information about an item in the checkout."
        lines: [CheckoutLineInput]!,
        "Checkout token."
        token: UUID
    ): CheckoutLinesAdd
    "Deletes checkout lines."
    checkoutLinesDelete(
        "A list of checkout lines."
        linesIds: [ID]!,
        "Checkout token."
        token: UUID!
    ): CheckoutLinesDelete
    "Updates checkout line in the existing checkout."
    checkoutLinesUpdate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "A list of checkout lines, each containing information about an item in the checkout."
        lines: [CheckoutLineInput]!,
        "Checkout token."
        token: UUID
    ): CheckoutLinesUpdate
    "Create a new payment for given checkout."
    checkoutPaymentCreate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Data required to create a new payment."
        input: PaymentInput!,
        "Checkout token."
        token: UUID
    ): CheckoutPaymentCreate
    "Remove a gift card or a voucher from a checkout."
    checkoutRemovePromoCode(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Gift card code or voucher code."
        promoCode: String,
        "Gift card or voucher ID."
        promoCodeId: ID,
        "Checkout token."
        token: UUID
    ): CheckoutRemovePromoCode
    "Update shipping address in the existing checkout."
    checkoutShippingAddressUpdate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "The mailing address to where the checkout will be shipped."
        shippingAddress: AddressInput!,
        "Checkout token."
        token: UUID
    ): CheckoutShippingAddressUpdate
    "Updates the shipping method of the checkout."
    checkoutShippingMethodUpdate(
        """

        The ID of the checkout.

        DEPRECATED: this field will be removed in Saleor 4.0. Use token instead.
        """
        checkoutId: ID,
        "Shipping method."
        shippingMethodId: ID!,
        "Checkout token."
        token: UUID
    ): CheckoutShippingMethodUpdate @deprecated(reason: "This field will be removed in Saleor 4.0. Use `checkoutDeliveryMethodUpdate` instead.")
    "Adds products to a collection."
    collectionAddProducts(
        "ID of a collection."
        collectionId: ID!,
        "List of product IDs."
        products: [ID]!
    ): CollectionAddProducts
    "Deletes collections."
    collectionBulkDelete(
        "List of collection IDs to delete."
        ids: [ID]!
    ): CollectionBulkDelete
    "Manage collection's availability in channels."
    collectionChannelListingUpdate(
        "ID of a collection to update."
        id: ID!,
        "Fields required to create or update collection channel listings."
        input: CollectionChannelListingUpdateInput!
    ): CollectionChannelListingUpdate
    "Creates a new collection."
    collectionCreate(
        "Fields required to create a collection."
        input: CollectionCreateInput!
    ): CollectionCreate
    "Deletes a collection."
    collectionDelete(
        "ID of a collection to delete."
        id: ID!
    ): CollectionDelete
    "Remove products from a collection."
    collectionRemoveProducts(
        "ID of a collection."
        collectionId: ID!,
        "List of product IDs."
        products: [ID]!
    ): CollectionRemoveProducts
    "Reorder the products of a collection."
    collectionReorderProducts(
        "ID of a collection."
        collectionId: ID!,
        "The collection products position operations."
        moves: [MoveProductInput]!
    ): CollectionReorderProducts
    "Creates/updates translations for a collection."
    collectionTranslate(
        "Collection ID or CollectionTranslatableContent ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslate
    "Updates a collection."
    collectionUpdate(
        "ID of a collection to update."
        id: ID!,
        "Fields required to update a collection."
        input: CollectionInput!
    ): CollectionUpdate
    "Confirm user account with token sent by email during registration."
    confirmAccount(
        "E-mail of the user performing account confirmation."
        email: String!,
        "A one-time token required to confirm the account."
        token: String!
    ): ConfirmAccount
    "Confirm the email change of the logged-in user."
    confirmEmailChange(
        "Slug of a channel which will be used to notify users. Optional when only one channel exists."
        channel: String,
        "A one-time token required to change the email."
        token: String!
    ): ConfirmEmailChange
    "Creates new warehouse."
    createWarehouse(
        "Fields required to create warehouse."
        input: WarehouseCreateInput!
    ): WarehouseCreate
    "Deletes customers."
    customerBulkDelete(
        "List of user IDs to delete."
        ids: [ID]!
    ): CustomerBulkDelete
    "Creates a new customer."
    customerCreate(
        "Fields required to create a customer."
        input: UserCreateInput!
    ): CustomerCreate
    "Deletes a customer."
    customerDelete(
        "ID of a customer to delete."
        id: ID!
    ): CustomerDelete
    "Updates an existing customer."
    customerUpdate(
        "ID of a customer to update."
        id: ID!,
        "Fields required to update a customer."
        input: CustomerInput!
    ): CustomerUpdate
    "Delete metadata of an object."
    deleteMetadata(
        "ID or token (for Order and Checkout) of an object to update."
        id: ID!,
        "Metadata keys to delete."
        keys: [String!]!
    ): DeleteMetadata
    "Delete object's private metadata."
    deletePrivateMetadata(
        "ID or token (for Order and Checkout) of an object to update."
        id: ID!,
        "Metadata keys to delete."
        keys: [String!]!
    ): DeletePrivateMetadata
    "Deletes selected warehouse."
    deleteWarehouse(
        "ID of a warehouse to delete."
        id: ID!
    ): WarehouseDelete
    "Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    digitalContentCreate(
        "Fields required to create a digital content."
        input: DigitalContentUploadInput!,
        "ID of a product variant to upload digital content."
        variantId: ID!
    ): DigitalContentCreate
    "Remove digital content assigned to given variant."
    digitalContentDelete(
        "ID of a product variant with digital content to remove."
        variantId: ID!
    ): DigitalContentDelete
    "Update digital content."
    digitalContentUpdate(
        "Fields required to update a digital content."
        input: DigitalContentInput!,
        "ID of a product variant with digital content to update."
        variantId: ID!
    ): DigitalContentUpdate
    "Generate new URL to digital content."
    digitalContentUrlCreate(
        "Fields required to create a new url."
        input: DigitalContentUrlCreateInput!
    ): DigitalContentUrlCreate
    "Deletes draft orders."
    draftOrderBulkDelete(
        "List of draft order IDs to delete."
        ids: [ID]!
    ): DraftOrderBulkDelete
    "Completes creating an order."
    draftOrderComplete(
        "ID of the order that will be completed."
        id: ID!
    ): DraftOrderComplete
    "Creates a new draft order."
    draftOrderCreate(
        "Fields required to create an order."
        input: DraftOrderCreateInput!
    ): DraftOrderCreate
    "Deletes a draft order."
    draftOrderDelete(
        "ID of a draft order to delete."
        id: ID!
    ): DraftOrderDelete
    "Deletes order lines."
    draftOrderLinesBulkDelete(
        "List of order lines IDs to delete."
        ids: [ID]!
    ): DraftOrderLinesBulkDelete @deprecated(reason: "This field will be removed in Saleor 4.0.")
    "Updates a draft order."
    draftOrderUpdate(
        "ID of a draft order to update."
        id: ID!,
        "Fields required to update an order."
        input: DraftOrderInput!
    ): DraftOrderUpdate
    "Retries event delivery."
    eventDeliveryRetry(
        "ID of the event delivery to retry."
        id: ID!
    ): EventDeliveryRetry
    "New in Saleor 3.1. Export gift cards to csv file. Note: this feature is in a preview state and can be subject to changes at later point."
    exportGiftCards(
        "Fields required to export gift cards data."
        input: ExportGiftCardsInput!
    ): ExportGiftCards
    "Export products to csv file."
    exportProducts(
        "Fields required to export product data."
        input: ExportProductsInput!
    ): ExportProducts
    "Prepare external authentication url for user by custom plugin."
    externalAuthenticationUrl(
        "The data required by plugin to create external authentication url."
        input: JSONString!,
        "The ID of the authentication plugin."
        pluginId: String!
    ): ExternalAuthenticationUrl
    "Logout user by custom plugin."
    externalLogout(
        "The data required by plugin to proceed the logout process."
        input: JSONString!,
        "The ID of the authentication plugin."
        pluginId: String!
    ): ExternalLogout
    "New in Saleor 3.1. Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload."
    externalNotificationTrigger(
        "Channel slug. Saleor will send a notification within a provided channel. Please, make sure that necessary plugins are active."
        channel: String!,
        "Input for External Notification Trigger. "
        input: ExternalNotificationTriggerInput!,
        "The ID of notification plugin."
        pluginId: String
    ): ExternalNotificationTrigger
    "Obtain external access tokens for user by custom plugin."
    externalObtainAccessTokens(
        "The data required by plugin to create authentication data."
        input: JSONString!,
        "The ID of the authentication plugin."
        pluginId: String!
    ): ExternalObtainAccessTokens
    "Refresh user's access by custom plugin."
    externalRefresh(
        "The data required by plugin to proceed the refresh process."
        input: JSONString!,
        "The ID of the authentication plugin."
        pluginId: String!
    ): ExternalRefresh
    "Verify external authentication data by plugin."
    externalVerify(
        "The data required by plugin to proceed the verification."
        input: JSONString!,
        "The ID of the authentication plugin."
        pluginId: String!
    ): ExternalVerify
    "Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    fileUpload(
        "Represents a file in a multipart request."
        file: Upload!
    ): FileUpload
    "Activate a gift card."
    giftCardActivate(
        "ID of a gift card to activate."
        id: ID!
    ): GiftCardActivate
    "New in Saleor 3.1. Adds note to the gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardAddNote(
        "ID of the gift card to add a note for."
        id: ID!,
        "Fields required to create a note for the gift card."
        input: GiftCardAddNoteInput!
    ): GiftCardAddNote
    "New in Saleor 3.1. Activate gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardBulkActivate(
        "List of gift card IDs to activate."
        ids: [ID]!
    ): GiftCardBulkActivate
    "New in Saleor 3.1. Create gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardBulkCreate(
        "Fields required to create gift cards."
        input: GiftCardBulkCreateInput!
    ): GiftCardBulkCreate
    "New in Saleor 3.1. Deactivate gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardBulkDeactivate(
        "List of gift card IDs to deactivate."
        ids: [ID]!
    ): GiftCardBulkDeactivate
    "New in Saleor 3.1. Delete gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardBulkDelete(
        "List of gift card IDs to delete."
        ids: [ID]!
    ): GiftCardBulkDelete
    "Creates a new gift card."
    giftCardCreate(
        "Fields required to create a gift card."
        input: GiftCardCreateInput!
    ): GiftCardCreate
    "Deactivate a gift card."
    giftCardDeactivate(
        "ID of a gift card to deactivate."
        id: ID!
    ): GiftCardDeactivate
    "New in Saleor 3.1. Delete gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardDelete(
        "ID of the gift card to delete."
        id: ID!
    ): GiftCardDelete
    "New in Saleor 3.1. Resend a gift card. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardResend(
        "Fields required to resend a gift card."
        input: GiftCardResendInput!
    ): GiftCardResend
    "Update gift card settings."
    giftCardSettingsUpdate(
        "Fields required to update gift card settings."
        input: GiftCardSettingsUpdateInput!
    ): GiftCardSettingsUpdate
    "Update a gift card."
    giftCardUpdate(
        "ID of a gift card to update."
        id: ID!,
        "Fields required to update a gift card."
        input: GiftCardUpdateInput!
    ): GiftCardUpdate
    "Creates a ready to send invoice."
    invoiceCreate(
        "Fields required when creating an invoice."
        input: InvoiceCreateInput!,
        "ID of the order related to invoice."
        orderId: ID!
    ): InvoiceCreate
    "Deletes an invoice."
    invoiceDelete(
        "ID of an invoice to delete."
        id: ID!
    ): InvoiceDelete
    "Request an invoice for the order using plugin."
    invoiceRequest(
        "Invoice number, if not provided it will be generated."
        number: String,
        "ID of the order related to invoice."
        orderId: ID!
    ): InvoiceRequest
    "Requests deletion of an invoice."
    invoiceRequestDelete(
        "ID of an invoice to request the deletion."
        id: ID!
    ): InvoiceRequestDelete
    "Send an invoice notification to the customer."
    invoiceSendNotification(
        "ID of an invoice to be sent."
        id: ID!
    ): InvoiceSendNotification
    "Updates an invoice."
    invoiceUpdate(
        "ID of an invoice to update."
        id: ID!,
        "Fields to use when updating an invoice."
        input: UpdateInvoiceInput!
    ): InvoiceUpdate
    "Deletes menus."
    menuBulkDelete(
        "List of menu IDs to delete."
        ids: [ID]!
    ): MenuBulkDelete
    "Creates a new Menu."
    menuCreate(
        "Fields required to create a menu."
        input: MenuCreateInput!
    ): MenuCreate
    "Deletes a menu."
    menuDelete(
        "ID of a menu to delete."
        id: ID!
    ): MenuDelete
    "Deletes menu items."
    menuItemBulkDelete(
        "List of menu item IDs to delete."
        ids: [ID]!
    ): MenuItemBulkDelete
    "Creates a new menu item."
    menuItemCreate(
        "Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item."
        input: MenuItemCreateInput!
    ): MenuItemCreate
    "Deletes a menu item."
    menuItemDelete(
        "ID of a menu item to delete."
        id: ID!
    ): MenuItemDelete
    "Moves items of menus."
    menuItemMove(
        "ID of the menu."
        menu: ID!,
        "The menu position data."
        moves: [MenuItemMoveInput]!
    ): MenuItemMove
    "Creates/updates translations for a menu item."
    menuItemTranslate(
        "MenuItem ID or MenuItemTranslatableContent ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslate
    "Updates a menu item."
    menuItemUpdate(
        "ID of a menu item to update."
        id: ID!,
        "Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item."
        input: MenuItemInput!
    ): MenuItemUpdate
    "Updates a menu."
    menuUpdate(
        "ID of a menu to update."
        id: ID!,
        "Fields required to update a menu."
        input: MenuInput!
    ): MenuUpdate
    "Adds note to the order."
    orderAddNote(
        "Fields required to create a note for the order."
        input: OrderAddNoteInput!,
        "ID of the order to add a note for."
        order: ID!
    ): OrderAddNote
    "Cancels orders."
    orderBulkCancel(
        "List of orders IDs to cancel."
        ids: [ID]!
    ): OrderBulkCancel
    "Cancel an order."
    orderCancel(
        "ID of the order to cancel."
        id: ID!
    ): OrderCancel
    "Capture an order."
    orderCapture(
        "Amount of money to capture."
        amount: PositiveDecimal!,
        "ID of the order to capture."
        id: ID!
    ): OrderCapture
    "Confirms an unconfirmed order by changing status to unfulfilled."
    orderConfirm(
        "ID of an order to confirm."
        id: ID!
    ): OrderConfirm
    "Adds discount to the order."
    orderDiscountAdd(
        "Fields required to create a discount for the order."
        input: OrderDiscountCommonInput!,
        "ID of an order to discount."
        orderId: ID!
    ): OrderDiscountAdd
    "Remove discount from the order."
    orderDiscountDelete(
        "ID of a discount to remove."
        discountId: ID!
    ): OrderDiscountDelete
    "Update discount for the order."
    orderDiscountUpdate(
        "ID of a discount to update."
        discountId: ID!,
        "Fields required to update a discount for the order."
        input: OrderDiscountCommonInput!
    ): OrderDiscountUpdate
    "Creates new fulfillments for an order."
    orderFulfill(
        "Fields required to create a fulfillment."
        input: OrderFulfillInput!,
        "ID of the order to be fulfilled."
        order: ID
    ): OrderFulfill
    "New in Saleor 3.1. Approve existing fulfillment."
    orderFulfillmentApprove(
        "True if stock could be exceeded."
        allowStockToBeExceeded: Boolean,
        "ID of a fulfillment to approve."
        id: ID!,
        "True if confirmation email should be send."
        notifyCustomer: Boolean!
    ): FulfillmentApprove
    "Cancels existing fulfillment and optionally restocks items."
    orderFulfillmentCancel(
        "ID of a fulfillment to cancel."
        id: ID!,
        "Fields required to cancel a fulfillment."
        input: FulfillmentCancelInput
    ): FulfillmentCancel
    "Refund products."
    orderFulfillmentRefundProducts(
        "Fields required to create an refund fulfillment."
        input: OrderRefundProductsInput!,
        "ID of the order to be refunded."
        order: ID!
    ): FulfillmentRefundProducts
    "Return products."
    orderFulfillmentReturnProducts(
        "Fields required to return products."
        input: OrderReturnProductsInput!,
        "ID of the order to be returned."
        order: ID!
    ): FulfillmentReturnProducts
    "Updates a fulfillment for an order."
    orderFulfillmentUpdateTracking(
        "ID of a fulfillment to update."
        id: ID!,
        "Fields required to update a fulfillment."
        input: FulfillmentUpdateTrackingInput!
    ): FulfillmentUpdateTracking
    "Deletes an order line from an order."
    orderLineDelete(
        "ID of the order line to delete."
        id: ID!
    ): OrderLineDelete
    "Remove discount applied to the order line."
    orderLineDiscountRemove(
        "ID of a order line to remove its discount"
        orderLineId: ID!
    ): OrderLineDiscountRemove
    "Update discount for the order line."
    orderLineDiscountUpdate(
        "Fields required to update price for the order line."
        input: OrderDiscountCommonInput!,
        "ID of a order line to update price"
        orderLineId: ID!
    ): OrderLineDiscountUpdate
    "Updates an order line of an order."
    orderLineUpdate(
        "ID of the order line to update."
        id: ID!,
        "Fields required to update an order line."
        input: OrderLineInput!
    ): OrderLineUpdate
    "Create order lines for an order."
    orderLinesCreate(
        "ID of the order to add the lines to."
        id: ID!,
        "Fields required to add order lines."
        input: [OrderLineCreateInput]!
    ): OrderLinesCreate
    "Mark order as manually paid."
    orderMarkAsPaid(
        "ID of the order to mark paid."
        id: ID!,
        "The external transaction reference."
        transactionReference: String
    ): OrderMarkAsPaid
    "Refund an order."
    orderRefund(
        "Amount of money to refund."
        amount: PositiveDecimal!,
        "ID of the order to refund."
        id: ID!
    ): OrderRefund
    "Update shop order settings."
    orderSettingsUpdate(
        "Fields required to update shop order settings."
        input: OrderSettingsUpdateInput!
    ): OrderSettingsUpdate
    "Updates an order."
    orderUpdate(
        "ID of an order to update."
        id: ID!,
        "Fields required to update an order."
        input: OrderUpdateInput!
    ): OrderUpdate
    "Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed."
    orderUpdateShipping(
        "Fields required to change shipping method of the order."
        input: OrderUpdateShippingInput!,
        "ID of the order to update a shipping method."
        order: ID!
    ): OrderUpdateShipping
    "Void an order."
    orderVoid(
        "ID of the order to void."
        id: ID!
    ): OrderVoid
    "Assign attributes to a given page type."
    pageAttributeAssign(
        "The IDs of the attributes to assign."
        attributeIds: [ID!]!,
        "ID of the page type to assign the attributes into."
        pageTypeId: ID!
    ): PageAttributeAssign
    "Unassign attributes from a given page type."
    pageAttributeUnassign(
        "The IDs of the attributes to unassign."
        attributeIds: [ID!]!,
        "ID of the page type from which the attributes should be unassign."
        pageTypeId: ID!
    ): PageAttributeUnassign
    "Deletes pages."
    pageBulkDelete(
        "List of page IDs to delete."
        ids: [ID]!
    ): PageBulkDelete
    "Publish pages."
    pageBulkPublish(
        "List of page IDs to (un)publish."
        ids: [ID]!,
        "Determine if pages will be published or not."
        isPublished: Boolean!
    ): PageBulkPublish
    "Creates a new page."
    pageCreate(
        "Fields required to create a page."
        input: PageCreateInput!
    ): PageCreate
    "Deletes a page."
    pageDelete(
        "ID of a page to delete."
        id: ID!
    ): PageDelete
    "Reorder page attribute values."
    pageReorderAttributeValues(
        "ID of an attribute."
        attributeId: ID!,
        "The list of reordering operations for given attribute values."
        moves: [ReorderInput]!,
        "ID of a page."
        pageId: ID!
    ): PageReorderAttributeValues
    "Creates/updates translations for a page."
    pageTranslate(
        "Page ID or PageTranslatableContent ID."
        id: ID!,
        input: PageTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): PageTranslate
    "Delete page types."
    pageTypeBulkDelete(
        "List of page type IDs to delete"
        ids: [ID!]!
    ): PageTypeBulkDelete
    "Create a new page type."
    pageTypeCreate(
        "Fields required to create page type."
        input: PageTypeCreateInput!
    ): PageTypeCreate
    "Delete a page type."
    pageTypeDelete(
        "ID of the page type to delete."
        id: ID!
    ): PageTypeDelete
    "Reorder the attributes of a page type."
    pageTypeReorderAttributes(
        "The list of attribute reordering operations."
        moves: [ReorderInput!]!,
        "ID of a page type."
        pageTypeId: ID!
    ): PageTypeReorderAttributes
    "Update page type."
    pageTypeUpdate(
        "ID of the page type to update."
        id: ID,
        "Fields required to update page type."
        input: PageTypeUpdateInput!
    ): PageTypeUpdate
    "Updates an existing page."
    pageUpdate(
        "ID of a page to update."
        id: ID!,
        "Fields required to update a page."
        input: PageInput!
    ): PageUpdate
    "Change the password of the logged in user."
    passwordChange(
        "New user password."
        newPassword: String!,
        "Current user password."
        oldPassword: String!
    ): PasswordChange
    "Captures the authorized payment amount."
    paymentCapture(
        "Transaction amount."
        amount: PositiveDecimal,
        "Payment ID."
        paymentId: ID!
    ): PaymentCapture
    "Check payment balance."
    paymentCheckBalance(
        "Fields required to check payment balance."
        input: PaymentCheckBalanceInput!
    ): PaymentCheckBalance
    "Initializes payment process when it is required by gateway."
    paymentInitialize(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "A gateway name used to initialize the payment."
        gateway: String!,
        "Client-side generated data required to initialize the payment."
        paymentData: JSONString
    ): PaymentInitialize
    "Refunds the captured payment amount."
    paymentRefund(
        "Transaction amount."
        amount: PositiveDecimal,
        "Payment ID."
        paymentId: ID!
    ): PaymentRefund
    "Voids the authorized payment."
    paymentVoid(
        "Payment ID."
        paymentId: ID!
    ): PaymentVoid
    "Create new permission group."
    permissionGroupCreate(
        "Input fields to create permission group."
        input: PermissionGroupCreateInput!
    ): PermissionGroupCreate
    "Delete permission group."
    permissionGroupDelete(
        "ID of the group to delete."
        id: ID!
    ): PermissionGroupDelete
    "Update permission group."
    permissionGroupUpdate(
        "ID of the group to update."
        id: ID!,
        "Input fields to create permission group."
        input: PermissionGroupUpdateInput!
    ): PermissionGroupUpdate
    "Update plugin configuration."
    pluginUpdate(
        "ID of a channel for which the data should be modified."
        channelId: ID,
        "ID of plugin to update."
        id: ID!,
        "Fields required to update a plugin configuration."
        input: PluginUpdateInput!
    ): PluginUpdate
    "Assign attributes to a given product type."
    productAttributeAssign(
        "The operations to perform."
        operations: [ProductAttributeAssignInput]!,
        "ID of the product type to assign the attributes into."
        productTypeId: ID!
    ): ProductAttributeAssign
    "New in Saleor 3.1. Update attributes assigned to product variant for given product type."
    productAttributeAssignmentUpdate(
        "The operations to perform."
        operations: [ProductAttributeAssignmentUpdateInput]!,
        "ID of the product type to assign the attributes into."
        productTypeId: ID!
    ): ProductAttributeAssignmentUpdate
    "Un-assign attributes from a given product type."
    productAttributeUnassign(
        "The IDs of the attributes to unassign."
        attributeIds: [ID]!,
        "ID of the product type from which the attributes should be unassigned."
        productTypeId: ID!
    ): ProductAttributeUnassign
    "Deletes products."
    productBulkDelete(
        "List of product IDs to delete."
        ids: [ID]!
    ): ProductBulkDelete
    "Manage product's availability in channels."
    productChannelListingUpdate(
        "ID of a product to update."
        id: ID!,
        "Fields required to create or update product channel listings."
        input: ProductChannelListingUpdateInput!
    ): ProductChannelListingUpdate
    "Creates a new product."
    productCreate(
        "Fields required to create a product."
        input: ProductCreateInput!
    ): ProductCreate
    "Deletes a product."
    productDelete(
        "ID of a product to delete."
        id: ID!
    ): ProductDelete
    "Deletes product media."
    productMediaBulkDelete(
        "List of product media IDs to delete."
        ids: [ID]!
    ): ProductMediaBulkDelete
    "Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    productMediaCreate(
        "Fields required to create a product media."
        input: ProductMediaCreateInput!
    ): ProductMediaCreate
    "Deletes a product media."
    productMediaDelete(
        "ID of a product media to delete."
        id: ID!
    ): ProductMediaDelete
    "Changes ordering of the product media."
    productMediaReorder(
        "IDs of a product media in the desired order."
        mediaIds: [ID]!,
        "ID of product that media order will be altered."
        productId: ID!
    ): ProductMediaReorder
    "Updates a product media."
    productMediaUpdate(
        "ID of a product media to update."
        id: ID!,
        "Fields required to update a product media."
        input: ProductMediaUpdateInput!
    ): ProductMediaUpdate
    "Reorder product attribute values."
    productReorderAttributeValues(
        "ID of an attribute."
        attributeId: ID!,
        "The list of reordering operations for given attribute values."
        moves: [ReorderInput]!,
        "ID of a product."
        productId: ID!
    ): ProductReorderAttributeValues
    "Creates/updates translations for a product."
    productTranslate(
        "Product ID or ProductTranslatableContent ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ProductTranslate
    "Deletes product types."
    productTypeBulkDelete(
        "List of product type IDs to delete."
        ids: [ID]!
    ): ProductTypeBulkDelete
    "Creates a new product type."
    productTypeCreate(
        "Fields required to create a product type."
        input: ProductTypeInput!
    ): ProductTypeCreate
    "Deletes a product type."
    productTypeDelete(
        "ID of a product type to delete."
        id: ID!
    ): ProductTypeDelete
    "Reorder the attributes of a product type."
    productTypeReorderAttributes(
        "The list of attribute reordering operations."
        moves: [ReorderInput]!,
        "ID of a product type."
        productTypeId: ID!,
        "The attribute type to reorder."
        type: ProductAttributeType!
    ): ProductTypeReorderAttributes
    "Updates an existing product type."
    productTypeUpdate(
        "ID of a product type to update."
        id: ID!,
        "Fields required to update a product type."
        input: ProductTypeInput!
    ): ProductTypeUpdate
    "Updates an existing product."
    productUpdate(
        "ID of a product to update."
        id: ID!,
        "Fields required to update a product."
        input: ProductInput!
    ): ProductUpdate
    "Creates product variants for a given product."
    productVariantBulkCreate(
        "ID of the product to create the variants for."
        product: ID!,
        "Input list of product variants to create."
        variants: [ProductVariantBulkCreateInput]!
    ): ProductVariantBulkCreate
    "Deletes product variants."
    productVariantBulkDelete(
        "List of product variant IDs to delete."
        ids: [ID]!
    ): ProductVariantBulkDelete
    "Manage product variant prices in channels."
    productVariantChannelListingUpdate(
        "ID of a product variant to update."
        id: ID!,
        "List of fields required to create or upgrade product variant channel listings."
        input: [ProductVariantChannelListingAddInput!]!
    ): ProductVariantChannelListingUpdate
    "Creates a new variant for a product."
    productVariantCreate(
        "Fields required to create a product variant."
        input: ProductVariantCreateInput!
    ): ProductVariantCreate
    "Deletes a product variant."
    productVariantDelete(
        "ID of a product variant to delete."
        id: ID!
    ): ProductVariantDelete
    "New in Saleor 3.1. Deactivates product variant preorder. It changes all preorder allocation into regular allocation. Note: this feature is in a preview state and can be subject to changes at later point."
    productVariantPreorderDeactivate(
        "ID of a variant which preorder should be deactivated."
        id: ID!
    ): ProductVariantPreorderDeactivate
    "Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook."
    productVariantReorder(
        "The list of variant reordering operations."
        moves: [ReorderInput]!,
        "Id of product that variants order will be altered."
        productId: ID!
    ): ProductVariantReorder
    "Reorder product variant attribute values."
    productVariantReorderAttributeValues(
        "ID of an attribute."
        attributeId: ID!,
        "The list of reordering operations for given attribute values."
        moves: [ReorderInput]!,
        "ID of a product variant."
        variantId: ID!
    ): ProductVariantReorderAttributeValues
    "Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook."
    productVariantSetDefault(
        "Id of a product that will have the default variant set."
        productId: ID!,
        "Id of a variant that will be set as default."
        variantId: ID!
    ): ProductVariantSetDefault
    "Creates stocks for product variant."
    productVariantStocksCreate(
        "Input list of stocks to create."
        stocks: [StockInput!]!,
        "ID of a product variant for which stocks will be created."
        variantId: ID!
    ): ProductVariantStocksCreate
    "Delete stocks from product variant."
    productVariantStocksDelete(
        "ID of product variant for which stocks will be deleted."
        variantId: ID!,
        warehouseIds: [ID!]
    ): ProductVariantStocksDelete
    "Update stocks for product variant."
    productVariantStocksUpdate(
        "Input list of stocks to create."
        stocks: [StockInput!]!,
        "ID of a product variant for which stocks will be created."
        variantId: ID!
    ): ProductVariantStocksUpdate
    "Creates/updates translations for a product variant."
    productVariantTranslate(
        "ProductVariant ID or ProductVariantTranslatableContent ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslate
    "Updates an existing variant for product."
    productVariantUpdate(
        "ID of a product variant to update."
        id: ID!,
        "Fields required to update a product variant."
        input: ProductVariantInput!
    ): ProductVariantUpdate
    "Request email change of the logged in user."
    requestEmailChange(
        "Slug of a channel which will be used to notify users. Optional when only one channel exists."
        channel: String,
        "New user email."
        newEmail: String!,
        "User password."
        password: String!,
        "URL of a view where users should be redirected to update the email address. URL in RFC 1808 format."
        redirectUrl: String!
    ): RequestEmailChange
    "Sends an email with the account password modification link."
    requestPasswordReset(
        "Slug of a channel which will be used for notify user. Optional when only one channel exists."
        channel: String,
        "Email of the user that will be used for password recovery."
        email: String!,
        "URL of a view where users should be redirected to reset the password. URL in RFC 1808 format."
        redirectUrl: String!
    ): RequestPasswordReset
    "Deletes sales."
    saleBulkDelete(
        "List of sale IDs to delete."
        ids: [ID]!
    ): SaleBulkDelete
    "Adds products, categories, collections to a voucher."
    saleCataloguesAdd(
        "ID of a sale."
        id: ID!,
        "Fields required to modify catalogue IDs of sale."
        input: CatalogueInput!
    ): SaleAddCatalogues
    "Removes products, categories, collections from a sale."
    saleCataloguesRemove(
        "ID of a sale."
        id: ID!,
        "Fields required to modify catalogue IDs of sale."
        input: CatalogueInput!
    ): SaleRemoveCatalogues
    "Manage sale's availability in channels."
    saleChannelListingUpdate(
        "ID of a sale to update."
        id: ID!,
        "Fields required to update sale channel listings."
        input: SaleChannelListingInput!
    ): SaleChannelListingUpdate
    "Creates a new sale."
    saleCreate(
        "Fields required to create a sale."
        input: SaleInput!
    ): SaleCreate
    "Deletes a sale."
    saleDelete(
        "ID of a sale to delete."
        id: ID!
    ): SaleDelete
    "Creates/updates translations for a sale."
    saleTranslate(
        "Sale ID or SaleTranslatableContent ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): SaleTranslate
    "Updates a sale."
    saleUpdate(
        "ID of a sale to update."
        id: ID!,
        "Fields required to update a sale."
        input: SaleInput!
    ): SaleUpdate
    "Sets the user's password from the token sent by email using the RequestPasswordReset mutation."
    setPassword(
        "Email of a user."
        email: String!,
        "Password of a user."
        password: String!,
        "A one-time token required to set the password."
        token: String!
    ): SetPassword
    "Manage shipping method's availability in channels."
    shippingMethodChannelListingUpdate(
        "ID of a shipping method to update."
        id: ID!,
        "Fields required to update shipping method channel listings."
        input: ShippingMethodChannelListingInput!
    ): ShippingMethodChannelListingUpdate
    "Deletes shipping prices."
    shippingPriceBulkDelete(
        "List of shipping price IDs to delete."
        ids: [ID]!
    ): ShippingPriceBulkDelete
    "Creates a new shipping price."
    shippingPriceCreate(
        "Fields required to create a shipping price."
        input: ShippingPriceInput!
    ): ShippingPriceCreate
    "Deletes a shipping price."
    shippingPriceDelete(
        "ID of a shipping price to delete."
        id: ID!
    ): ShippingPriceDelete
    "Exclude products from shipping price."
    shippingPriceExcludeProducts(
        "ID of a shipping price."
        id: ID!,
        "Exclude products input."
        input: ShippingPriceExcludeProductsInput!
    ): ShippingPriceExcludeProducts
    "Remove product from excluded list for shipping price."
    shippingPriceRemoveProductFromExclude(
        "ID of a shipping price."
        id: ID!,
        "List of products which will be removed from excluded list."
        products: [ID]!
    ): ShippingPriceRemoveProductFromExclude
    "Creates/updates translations for a shipping method."
    shippingPriceTranslate(
        "('ShippingMethodType ID or ShippingMethodTranslatableContent ID.',)"
        id: ID!,
        input: ShippingPriceTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ShippingPriceTranslate
    "Updates a new shipping price."
    shippingPriceUpdate(
        "ID of a shipping price to update."
        id: ID!,
        "Fields required to update a shipping price."
        input: ShippingPriceInput!
    ): ShippingPriceUpdate
    "Deletes shipping zones."
    shippingZoneBulkDelete(
        "List of shipping zone IDs to delete."
        ids: [ID]!
    ): ShippingZoneBulkDelete
    "Creates a new shipping zone."
    shippingZoneCreate(
        "Fields required to create a shipping zone."
        input: ShippingZoneCreateInput!
    ): ShippingZoneCreate
    "Deletes a shipping zone."
    shippingZoneDelete(
        "ID of a shipping zone to delete."
        id: ID!
    ): ShippingZoneDelete
    "Updates a new shipping zone."
    shippingZoneUpdate(
        "ID of a shipping zone to update."
        id: ID!,
        "Fields required to update a shipping zone."
        input: ShippingZoneUpdateInput!
    ): ShippingZoneUpdate
    "Update the shop's address. If the `null` value is passed, the currently selected address will be deleted."
    shopAddressUpdate(
        "Fields required to update shop address."
        input: AddressInput
    ): ShopAddressUpdate
    "Updates site domain of the shop."
    shopDomainUpdate(
        "Fields required to update site."
        input: SiteDomainInput
    ): ShopDomainUpdate
    "Fetch tax rates."
    shopFetchTaxRates: ShopFetchTaxRates
    "Creates/updates translations for shop settings."
    shopSettingsTranslate(
        "Fields required to update shop settings translations."
        input: ShopSettingsTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ShopSettingsTranslate
    "Updates shop settings."
    shopSettingsUpdate(
        "Fields required to update shop settings."
        input: ShopSettingsInput!
    ): ShopSettingsUpdate
    "Deletes staff users."
    staffBulkDelete(
        "List of user IDs to delete."
        ids: [ID]!
    ): StaffBulkDelete
    "Creates a new staff user."
    staffCreate(
        "Fields required to create a staff user."
        input: StaffCreateInput!
    ): StaffCreate
    "Deletes a staff user."
    staffDelete(
        "ID of a staff user to delete."
        id: ID!
    ): StaffDelete
    "Creates a new staff notification recipient."
    staffNotificationRecipientCreate(
        "Fields required to create a staff notification recipient."
        input: StaffNotificationRecipientInput!
    ): StaffNotificationRecipientCreate
    "Delete staff notification recipient."
    staffNotificationRecipientDelete(
        "ID of a staff notification recipient to delete."
        id: ID!
    ): StaffNotificationRecipientDelete
    "Updates a staff notification recipient."
    staffNotificationRecipientUpdate(
        "ID of a staff notification recipient to update."
        id: ID!,
        "Fields required to update a staff notification recipient."
        input: StaffNotificationRecipientInput!
    ): StaffNotificationRecipientUpdate
    "Updates an existing staff user."
    staffUpdate(
        "ID of a staff user to update."
        id: ID!,
        "Fields required to update a staff user."
        input: StaffUpdateInput!
    ): StaffUpdate
    "Create JWT token."
    tokenCreate(
        "Email of a user."
        email: String!,
        "Password of a user."
        password: String!
    ): CreateToken
    "Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie."
    tokenRefresh(
        "CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie."
        csrfToken: String,
        "Refresh token."
        refreshToken: String
    ): RefreshToken
    "Verify JWT token."
    tokenVerify(
        "JWT token to validate."
        token: String!
    ): VerifyToken
    "Deactivate all JWT tokens of the currently authenticated user."
    tokensDeactivateAll: DeactivateAllUserTokens
    "Remove shipping zone from given warehouse."
    unassignWarehouseShippingZone(
        "ID of a warehouse to update."
        id: ID!,
        "List of shipping zone IDs."
        shippingZoneIds: [ID!]!
    ): WarehouseShippingZoneUnassign
    "Updates metadata of an object."
    updateMetadata(
        "ID or token (for Order and Checkout) of an object to update."
        id: ID!,
        "Fields required to update the object's metadata."
        input: [MetadataInput!]!
    ): UpdateMetadata
    "Updates private metadata of an object."
    updatePrivateMetadata(
        "ID or token (for Order and Checkout) of an object to update."
        id: ID!,
        "Fields required to update the object's metadata."
        input: [MetadataInput!]!
    ): UpdatePrivateMetadata
    "Updates given warehouse."
    updateWarehouse(
        "ID of a warehouse to update."
        id: ID!,
        "Fields required to update warehouse."
        input: WarehouseUpdateInput!
    ): WarehouseUpdate
    "Deletes a user avatar. Only for staff members."
    userAvatarDelete: UserAvatarDelete
    "Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    userAvatarUpdate(
        "Represents an image file in a multipart request."
        image: Upload!
    ): UserAvatarUpdate
    "Activate or deactivate users."
    userBulkSetActive(
        "List of user IDs to (de)activate)."
        ids: [ID]!,
        "Determine if users will be set active or not."
        isActive: Boolean!
    ): UserBulkSetActive
    "Assign an media to a product variant."
    variantMediaAssign(
        "ID of a product media to assign to a variant."
        mediaId: ID!,
        "ID of a product variant."
        variantId: ID!
    ): VariantMediaAssign
    "Unassign an media from a product variant."
    variantMediaUnassign(
        "ID of a product media to unassign from a variant."
        mediaId: ID!,
        "ID of a product variant."
        variantId: ID!
    ): VariantMediaUnassign
    "Deletes vouchers."
    voucherBulkDelete(
        "List of voucher IDs to delete."
        ids: [ID]!
    ): VoucherBulkDelete
    "Adds products, categories, collections to a voucher."
    voucherCataloguesAdd(
        "ID of a voucher."
        id: ID!,
        "Fields required to modify catalogue IDs of voucher."
        input: CatalogueInput!
    ): VoucherAddCatalogues
    "Removes products, categories, collections from a voucher."
    voucherCataloguesRemove(
        "ID of a voucher."
        id: ID!,
        "Fields required to modify catalogue IDs of voucher."
        input: CatalogueInput!
    ): VoucherRemoveCatalogues
    "Manage voucher's availability in channels."
    voucherChannelListingUpdate(
        "ID of a voucher to update."
        id: ID!,
        "Fields required to update voucher channel listings."
        input: VoucherChannelListingInput!
    ): VoucherChannelListingUpdate
    "Creates a new voucher."
    voucherCreate(
        "Fields required to create a voucher."
        input: VoucherInput!
    ): VoucherCreate
    "Deletes a voucher."
    voucherDelete(
        "ID of a voucher to delete."
        id: ID!
    ): VoucherDelete
    "Creates/updates translations for a voucher."
    voucherTranslate(
        "Voucher ID or VoucherTranslatableContent ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslate
    "Updates a voucher."
    voucherUpdate(
        "ID of a voucher to update."
        id: ID!,
        "Fields required to update a voucher."
        input: VoucherInput!
    ): VoucherUpdate
    "Creates a new webhook subscription."
    webhookCreate(
        "Fields required to create a webhook."
        input: WebhookCreateInput!
    ): WebhookCreate
    "Deletes a webhook subscription."
    webhookDelete(
        "ID of a webhook to delete."
        id: ID!
    ): WebhookDelete
    "Updates a webhook subscription."
    webhookUpdate(
        "ID of a webhook to update."
        id: ID!,
        "Fields required to update a webhook."
        input: WebhookUpdateInput!
    ): WebhookUpdate
}

"Represents an order in the shop."
type Order implements Node & ObjectWithMetadata {
    "List of actions that can be performed in the current state of an order."
    actions: [OrderAction]!
    "New in Saleor 3.1. Collection points that can be used for this order. Note: this feature is in a preview state and can be subject to changes at later point."
    availableCollectionPoints: [Warehouse!]!
    "Shipping methods that can be used with this order."
    availableShippingMethods: [ShippingMethod] @deprecated(reason: "Use `shippingMethods`, this field will be removed in 4.0")
    billingAddress: Address
    "Informs whether a draft order can be finalized(turned into a regular order)."
    canFinalize: Boolean!
    channel: Channel!
    collectionPointName: String
    created: DateTime!
    customerNote: String!
    "New in Saleor 3.1. The delivery method selected for this checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    deliveryMethod: DeliveryMethod
    "Returns applied discount."
    discount: Money @deprecated(reason: "This field will be removed in Saleor 4.0. Use discounts field.")
    "Discount name."
    discountName: String @deprecated(reason: "This field will be removed in Saleor 4.0. Use discounts field.")
    "List of all discounts assigned to the order."
    discounts: [OrderDiscount!]
    displayGrossPrices: Boolean!
    "List of errors that occurred during order validation."
    errors: [OrderError!]!
    "List of events associated with the order."
    events: [OrderEvent]
    "List of shipments for the order."
    fulfillments: [Fulfillment]!
    "List of user gift cards."
    giftCards: [GiftCard]
    id: ID!
    "List of order invoices."
    invoices: [Invoice]
    "Informs if an order is fully paid."
    isPaid: Boolean!
    "Returns True, if order requires shipping."
    isShippingRequired: Boolean!
    languageCode: String! @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `languageCodeEnum` field to fetch the language code. ")
    "Order language code."
    languageCodeEnum: LanguageCodeEnum!
    "List of order lines."
    lines: [OrderLine]!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "User-friendly number of an order."
    number: String
    "The order origin."
    origin: OrderOriginEnum!
    "The ID of the order that was the base for this order."
    original: ID
    "Internal payment status."
    paymentStatus: PaymentChargeStatusEnum!
    "User-friendly payment status."
    paymentStatusDisplay: String!
    "List of payments for the order."
    payments: [Payment]
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    redirectUrl: String
    shippingAddress: Address
    "Shipping method for this order."
    shippingMethod: ShippingMethod @deprecated(reason: "This field will be removed in Saleor 4.0. Use `deliveryMethod` instead.")
    shippingMethodName: String
    "Shipping methods related to this order."
    shippingMethods: [ShippingMethod]
    "Total price of shipping."
    shippingPrice: TaxedMoney!
    shippingTaxRate: Float!
    status: OrderStatus!
    "User-friendly order status."
    statusDisplay: String
    "The sum of line prices not including shipping."
    subtotal: TaxedMoney!
    token: String!
    "Total amount of the order."
    total: TaxedMoney!
    "Amount authorized for the order."
    totalAuthorized: Money!
    "The difference between the paid and the order total amount."
    totalBalance: Money!
    "Amount captured by payment."
    totalCaptured: Money!
    trackingClientId: String!
    "Translated discount name."
    translatedDiscountName: String @deprecated(reason: "This field will be removed in Saleor 4.0. Use discounts field. ")
    "Undiscounted total amount of the order."
    undiscountedTotal: TaxedMoney!
    updatedAt: DateTime!
    user: User
    "Email address of the customer."
    userEmail: String
    voucher: Voucher
    weight: Weight
}

"Adds note to the order."
type OrderAddNote {
    errors: [OrderError!]!
    "Order note created."
    event: OrderEvent
    "Order with the note added."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Cancels orders."
type OrderBulkCancel {
    "Returns how many objects were affected."
    count: Int!
    errors: [OrderError!]!
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Cancel an order."
type OrderCancel {
    errors: [OrderError!]!
    "Canceled order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Capture an order."
type OrderCapture {
    errors: [OrderError!]!
    "Captured order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Confirms an unconfirmed order by changing status to unfulfilled."
type OrderConfirm {
    errors: [OrderError!]!
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type OrderCountableConnection {
    edges: [OrderCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type OrderCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Order!
}

"Contains all details related to the applied discount to the order."
type OrderDiscount implements Node {
    "Returns amount of discount."
    amount: Money!
    id: ID!
    name: String
    "Explanation for the applied discount."
    reason: String
    translatedName: String
    type: OrderDiscountType!
    "Value of the discount. Can store fixed value or percent value"
    value: PositiveDecimal!
    "Type of the discount: fixed or percent"
    valueType: DiscountValueTypeEnum!
}

"Adds discount to the order."
type OrderDiscountAdd {
    errors: [OrderError!]!
    "Order which has been discounted."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Remove discount from the order."
type OrderDiscountDelete {
    errors: [OrderError!]!
    "Order which has removed discount."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Update discount for the order."
type OrderDiscountUpdate {
    errors: [OrderError!]!
    "Order which has been discounted."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type OrderError {
    "A type of address that causes the error."
    addressType: AddressTypeEnum
    "The error code."
    code: OrderErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of order line IDs that cause the error."
    orderLines: [ID!]
    "List of product variants that are associated with the error"
    variants: [ID!]
    "Warehouse ID which causes the error."
    warehouse: ID
}

"History log of the order."
type OrderEvent implements Node {
    "Amount of money."
    amount: Float
    "App that performed the action."
    app: App
    "Composed ID of the Fulfillment."
    composedId: String
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "The discount applied to the order."
    discount: OrderEventDiscountObject
    "Email of the customer."
    email: String
    "Type of an email sent to the customer."
    emailType: OrderEventsEmailsEnum
    "The lines fulfilled."
    fulfilledItems: [FulfillmentLine]
    id: ID!
    "Number of an invoice related to the order."
    invoiceNumber: String
    "The concerned lines."
    lines: [OrderEventOrderLineObject]
    "Content of the event."
    message: String
    "User-friendly number of an order."
    orderNumber: String
    "List of oversold lines names."
    oversoldItems: [String]
    "The payment gateway of the payment."
    paymentGateway: String
    "The payment ID from the payment gateway."
    paymentId: String
    "Number of items."
    quantity: Int
    "The order which is related to this order."
    relatedOrder: Order
    "Define if shipping costs were included to the refund."
    shippingCostsIncluded: Boolean
    "The transaction reference of captured payment."
    transactionReference: String
    "Order event type."
    type: OrderEventsEnum
    "User who performed the action."
    user: User
    "The warehouse were items were restocked."
    warehouse: Warehouse
}

type OrderEventCountableConnection {
    edges: [OrderEventCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type OrderEventCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OrderEvent!
}

type OrderEventDiscountObject {
    "Returns amount of discount."
    amount: Money
    "Returns amount of discount."
    oldAmount: Money
    "Value of the discount. Can store fixed value or percent value."
    oldValue: PositiveDecimal
    "Type of the discount: fixed or percent."
    oldValueType: DiscountValueTypeEnum
    "Explanation for the applied discount."
    reason: String
    "Value of the discount. Can store fixed value or percent value."
    value: PositiveDecimal!
    "Type of the discount: fixed or percent."
    valueType: DiscountValueTypeEnum!
}

type OrderEventOrderLineObject {
    "The discount applied to the order line."
    discount: OrderEventDiscountObject
    "The variant name."
    itemName: String
    "The order line."
    orderLine: OrderLine
    "The variant quantity."
    quantity: Int
}

"Creates new fulfillments for an order."
type OrderFulfill {
    errors: [OrderError!]!
    "List of created fulfillments."
    fulfillments: [Fulfillment]
    "Fulfilled order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents order line of particular order."
type OrderLine implements Node {
    "List of allocations across warehouses."
    allocations: [Allocation!]
    digitalContentUrl: DigitalContentUrl
    id: ID!
    isShippingRequired: Boolean!
    productName: String!
    productSku: String
    productVariantId: String
    quantity: Int!
    quantityFulfilled: Int!
    "New in Saleor 3.1. A quantity of items remaining to be fulfilled."
    quantityToFulfill: Int!
    taxRate: Float!
    "The main thumbnail for the ordered product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Price of the order line."
    totalPrice: TaxedMoney!
    "Product name in the customer's language"
    translatedProductName: String!
    "Variant name in the customer's language"
    translatedVariantName: String!
    "Price of the single item in the order line without applied an order line discount."
    undiscountedUnitPrice: TaxedMoney!
    "The discount applied to the single order line."
    unitDiscount: Money!
    unitDiscountReason: String
    "Type of the discount: fixed or percent"
    unitDiscountType: DiscountValueTypeEnum
    "Value of the discount. Can store fixed value or percent value"
    unitDiscountValue: PositiveDecimal!
    "Price of the single item in the order line."
    unitPrice: TaxedMoney!
    "A purchased product variant. Note: this field may be null if the variant has been removed from stock at all."
    variant: ProductVariant
    variantName: String!
}

"Deletes an order line from an order."
type OrderLineDelete {
    errors: [OrderError!]!
    "A related order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "An order line that was deleted."
    orderLine: OrderLine
}

"Remove discount applied to the order line."
type OrderLineDiscountRemove {
    errors: [OrderError!]!
    "Order which is related to line which has removed discount."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Order line which has removed discount."
    orderLine: OrderLine
}

"Update discount for the order line."
type OrderLineDiscountUpdate {
    errors: [OrderError!]!
    "Order which is related to the discounted line."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Order line which has been discounted."
    orderLine: OrderLine
}

"Updates an order line of an order."
type OrderLineUpdate {
    errors: [OrderError!]!
    "Related order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    orderLine: OrderLine
}

"Create order lines for an order."
type OrderLinesCreate {
    errors: [OrderError!]!
    "Related order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "List of added order lines."
    orderLines: [OrderLine!]
}

"Mark order as manually paid."
type OrderMarkAsPaid {
    errors: [OrderError!]!
    "Order marked as paid."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Refund an order."
type OrderRefund {
    errors: [OrderError!]!
    "A refunded order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Order related settings from site settings."
type OrderSettings {
    automaticallyConfirmAllNewOrders: Boolean!
    automaticallyFulfillNonShippableGiftCard: Boolean!
}

type OrderSettingsError {
    "The error code."
    code: OrderSettingsErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update shop order settings."
type OrderSettingsUpdate {
    errors: [OrderSettingsError!]!
    "Order settings."
    orderSettings: OrderSettings
    orderSettingsErrors: [OrderSettingsError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates an order."
type OrderUpdate {
    errors: [OrderError!]!
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed."
type OrderUpdateShipping {
    errors: [OrderError!]!
    "Order with updated shipping method."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Void an order."
type OrderVoid {
    errors: [OrderError!]!
    "A voided order."
    order: Order
    orderErrors: [OrderError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"A static page that can be manually added by a shop operator through the dashboard."
type Page implements Node & ObjectWithMetadata {
    "List of attributes assigned to this product."
    attributes: [SelectedAttribute!]!
    "Content of the page (JSON)."
    content: JSONString
    "Content of the page (JSON)."
    contentJson: JSONString! @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `content` field instead.")
    created: DateTime!
    id: ID!
    isPublished: Boolean!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    pageType: PageType!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    publicationDate: Date
    seoDescription: String
    seoTitle: String
    slug: String!
    title: String!
    "Returns translated page fields for the given language code."
    translation(
        "A language code to return the translation for page."
        languageCode: LanguageCodeEnum!
    ): PageTranslation
}

"Assign attributes to a given page type."
type PageAttributeAssign {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The updated page type."
    pageType: PageType
}

"Unassign attributes from a given page type."
type PageAttributeUnassign {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The updated page type."
    pageType: PageType
}

"Deletes pages."
type PageBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Publish pages."
type PageBulkPublish {
    "Returns how many objects were affected."
    count: Int!
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PageCountableConnection {
    edges: [PageCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PageCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Page!
}

"Creates a new page."
type PageCreate {
    errors: [PageError!]!
    page: Page
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a page."
type PageDelete {
    errors: [PageError!]!
    page: Page
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PageError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: PageErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"Reorder page attribute values."
type PageReorderAttributeValues {
    errors: [PageError!]!
    "Page from which attribute values are reordered."
    page: Page
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PageTranslatableContent implements Node {
    "List of page content attribute values that can be translated."
    attributeValues: [AttributeValueTranslatableContent!]!
    content: JSONString
    "Content of the page (JSON)."
    contentJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `content` field instead.")
    id: ID!
    "('A static page that can be manually added by a shop operator ', 'through the dashboard.')"
    page: Page @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    seoDescription: String
    seoTitle: String
    title: String!
    "Returns translated page fields for the given language code."
    translation(
        "A language code to return the translation for page."
        languageCode: LanguageCodeEnum!
    ): PageTranslation
}

"Creates/updates translations for a page."
type PageTranslate {
    errors: [TranslationError!]!
    page: PageTranslatableContent
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PageTranslation implements Node {
    content: JSONString
    "Translated description of the page (JSON)."
    contentJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `content` field instead.")
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    seoDescription: String
    seoTitle: String
    title: String
}

"Represents a type of page. It defines what attributes are available to pages of this type."
type PageType implements Node & ObjectWithMetadata {
    "Page attributes of that page type."
    attributes: [Attribute]
    "Attributes that can be assigned to the page type."
    availableAttributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): AttributeCountableConnection
    "Whether page type has pages assigned."
    hasPages: Boolean
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    slug: String!
}

"Delete page types."
type PageTypeBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PageTypeCountableConnection {
    edges: [PageTypeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PageTypeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PageType!
}

"Create a new page type."
type PageTypeCreate {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    pageType: PageType
}

"Delete a page type."
type PageTypeDelete {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    pageType: PageType
}

"Reorder the attributes of a page type."
type PageTypeReorderAttributes {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Page type from which attributes are reordered."
    pageType: PageType
}

"Update page type."
type PageTypeUpdate {
    errors: [PageError!]!
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    pageType: PageType
}

"Updates an existing page."
type PageUpdate {
    errors: [PageError!]!
    page: Page
    pageErrors: [PageError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Change the password of the logged in user."
type PasswordChange {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "A user instance with a new password."
    user: User
}

"Represents a payment of a given type."
type Payment implements Node & ObjectWithMetadata {
    "List of actions that can be performed in the current state of a payment."
    actions: [OrderAction]!
    "Maximum amount of money that can be captured."
    availableCaptureAmount: Money
    "Maximum amount of money that can be refunded."
    availableRefundAmount: Money
    "Total amount captured for this payment."
    capturedAmount: Money
    "Internal payment status."
    chargeStatus: PaymentChargeStatusEnum!
    checkout: Checkout
    created: DateTime!
    "The details of the card used for this payment."
    creditCard: CreditCard
    customerIpAddress: String
    gateway: String!
    id: ID!
    isActive: Boolean!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    modified: DateTime!
    order: Order
    paymentMethodType: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    token: String!
    "Total amount of the payment."
    total: Money
    "List of all transactions within this payment."
    transactions: [Transaction]
}

"Captures the authorized payment amount."
type PaymentCapture {
    errors: [PaymentError!]!
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Check payment balance."
type PaymentCheckBalance {
    "Response from the gateway."
    data: JSONString
    errors: [PaymentError!]!
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PaymentCountableConnection {
    edges: [PaymentCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PaymentCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Payment!
}

type PaymentError {
    "The error code."
    code: PaymentErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of varint IDs which causes the error."
    variants: [ID!]
}

"Available payment gateway backend with configuration necessary to setup client."
type PaymentGateway {
    "Payment gateway client configuration."
    config: [GatewayConfigLine!]!
    "Payment gateway supported currencies."
    currencies: [String]!
    "Payment gateway ID."
    id: ID!
    "Payment gateway name."
    name: String!
}

"Initializes payment process when it is required by gateway."
type PaymentInitialize {
    errors: [PaymentError!]!
    initializedPayment: PaymentInitialized
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Server-side data generated by a payment gateway. Optional step when the payment provider requires an additional action to initialize payment session."
type PaymentInitialized {
    "Initialized data by gateway."
    data: JSONString
    "ID of a payment gateway."
    gateway: String!
    "Payment gateway name."
    name: String!
}

"Refunds the captured payment amount."
type PaymentRefund {
    errors: [PaymentError!]!
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents a payment source stored for user in payment gateway, such as credit card."
type PaymentSource {
    "Stored credit card details if available."
    creditCardInfo: CreditCard
    "Payment gateway name."
    gateway: String!
    "New in Saleor 3.1. List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "ID of stored payment method."
    paymentMethodId: String
}

"Voids the authorized payment."
type PaymentVoid {
    errors: [PaymentError!]!
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents a permission object in a friendly form."
type Permission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
}

"Create new permission group."
type PermissionGroupCreate {
    errors: [PermissionGroupError!]!
    group: Group
    permissionGroupErrors: [PermissionGroupError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Delete permission group."
type PermissionGroupDelete {
    errors: [PermissionGroupError!]!
    group: Group
    permissionGroupErrors: [PermissionGroupError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type PermissionGroupError {
    "The error code."
    code: PermissionGroupErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
    "List of user IDs which causes the error."
    users: [ID!]
}

"Update permission group."
type PermissionGroupUpdate {
    errors: [PermissionGroupError!]!
    group: Group
    permissionGroupErrors: [PermissionGroupError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Plugin."
type Plugin {
    "Channel-specific plugin configuration."
    channelConfigurations: [PluginConfiguration!]!
    "Description of the plugin."
    description: String!
    "Global configuration of the plugin (not channel-specific)."
    globalConfiguration: PluginConfiguration
    "Identifier of the plugin."
    id: ID!
    "Name of the plugin."
    name: String!
}

"Stores information about a configuration of plugin."
type PluginConfiguration {
    "Determines if plugin is active or not."
    active: Boolean!
    "The channel to which the plugin configuration is assigned to."
    channel: Channel
    "Configuration of the plugin."
    configuration: [ConfigurationItem]
}

type PluginCountableConnection {
    edges: [PluginCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PluginCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Plugin!
}

type PluginError {
    "The error code."
    code: PluginErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update plugin configuration."
type PluginUpdate {
    errors: [PluginError!]!
    plugin: Plugin
    pluginsErrors: [PluginError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents preorder settings for product variant."
type PreorderData {
    "Preorder end date."
    endDate: DateTime
    "Total number of sold product variant during preorder."
    globalSoldUnits: Int!
    "The global preorder threshold for product variant."
    globalThreshold: Int
}

"Represents preorder variant data for channel."
type PreorderThreshold {
    "Preorder threshold for product variant in this channel."
    quantity: Int
    "Number of sold product variant in this channel."
    soldUnits: Int!
}

"Represents an individual item for sale in the storefront."
type Product implements Node & ObjectWithMetadata {
    "List of attributes assigned to this product."
    attributes: [SelectedAttribute!]!
    "Date when product is available for purchase. "
    availableForPurchase: Date
    category: Category
    "Channel given to retrieve this product. Also used by federation gateway to resolve this object in a federated query."
    channel: String
    "List of availability in channels for the product."
    channelListings: [ProductChannelListing!]
    chargeTaxes: Boolean!
    "List of collections for the product."
    collections: [Collection]
    created: DateTime!
    defaultVariant: ProductVariant
    description: JSONString
    "Description of the product (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    "Get a single product image by ID."
    imageById(
        "ID of a product image."
        id: ID
    ): ProductImage @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `mediaById` field instead.")
    "List of images for the product."
    images: [ProductImage] @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `media` field instead.")
    "Whether the product is in stock and visible or not."
    isAvailable(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput
    ): Boolean
    "Whether the product is available for purchase."
    isAvailableForPurchase: Boolean
    "List of media for the product."
    media: [ProductMedia!]
    "Get a single product media by ID."
    mediaById(
        "ID of a product media."
        id: ID
    ): ProductMedia
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Lists the storefront product's pricing, the current price and discounts, only meant for displaying."
    pricing(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput
    ): ProductPricingInfo
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productType: ProductType!
    rating: Float
    seoDescription: String
    seoTitle: String
    slug: String!
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "The main thumbnail for a product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Returns translated product fields for the given language code."
    translation(
        "A language code to return the translation for product."
        languageCode: LanguageCodeEnum!
    ): ProductTranslation
    updatedAt: DateTime!
    "List of variants for the product."
    variants: [ProductVariant]
    weight: Weight
}

"Assign attributes to a given product type."
type ProductAttributeAssign {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The updated product type."
    productType: ProductType
}

"New in Saleor 3.1. Update attributes assigned to product variant for given product type."
type ProductAttributeAssignmentUpdate {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The updated product type."
    productType: ProductType
}

"Un-assign attributes from a given product type."
type ProductAttributeUnassign {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "The updated product type."
    productType: ProductType
}

"Deletes products."
type ProductBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents product channel listing."
type ProductChannelListing implements Node {
    availableForPurchase: Date
    channel: Channel!
    "The price of the cheapest variant (including discounts)."
    discountedPrice: Money
    id: ID!
    "Whether the product is available for purchase."
    isAvailableForPurchase: Boolean
    isPublished: Boolean!
    "Range of margin percentage value."
    margin: Margin
    "Lists the storefront product's pricing, the current price and discounts, only meant for displaying."
    pricing(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput
    ): ProductPricingInfo
    publicationDate: Date
    "Purchase cost of product."
    purchaseCost: MoneyRange
    visibleInListings: Boolean!
}

type ProductChannelListingError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "List of channels IDs which causes the error."
    channels: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
    "List of variants IDs which causes the error."
    variants: [ID!]
}

"Manage product's availability in channels."
type ProductChannelListingUpdate {
    errors: [ProductChannelListingError!]!
    "An updated product instance."
    product: Product
    productChannelListingErrors: [ProductChannelListingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductCountableConnection {
    edges: [ProductCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Product!
}

"Creates a new product."
type ProductCreate {
    errors: [ProductError!]!
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a product."
type ProductDelete {
    errors: [ProductError!]!
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of attribute values IDs which causes the error."
    values: [ID!]
}

"Represents a product image."
type ProductImage {
    "The alt text of the image."
    alt: String
    "The ID of the image."
    id: ID!
    "The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
    "The URL of the image."
    url(
        "Size of the image."
        size: Int
    ): String!
}

"Represents a product media."
type ProductMedia implements Node {
    alt: String!
    id: ID!
    oembedData: JSONString!
    sortOrder: Int
    type: ProductMediaType!
    "The URL of the media."
    url(
        "Size of the image."
        size: Int
    ): String!
}

"Deletes product media."
type ProductMediaBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type ProductMediaCreate {
    errors: [ProductError!]!
    media: ProductMedia
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a product media."
type ProductMediaDelete {
    errors: [ProductError!]!
    media: ProductMedia
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Changes ordering of the product media."
type ProductMediaReorder {
    errors: [ProductError!]!
    media: [ProductMedia!]
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates a product media."
type ProductMediaUpdate {
    errors: [ProductError!]!
    media: ProductMedia
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents availability of a product in the storefront."
type ProductPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The discounted price range of the product variants."
    priceRange: TaxedMoneyRange
    "The discounted price range of the product variants in the local currency."
    priceRangeLocalCurrency: TaxedMoneyRange
    "The undiscounted price range of the product variants."
    priceRangeUndiscounted: TaxedMoneyRange
}

"Reorder product attribute values."
type ProductReorderAttributeValues {
    errors: [ProductError!]!
    "Product from which attribute values are reordered."
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductTranslatableContent implements Node {
    "List of product attribute values that can be translated."
    attributeValues: [AttributeValueTranslatableContent!]!
    description: JSONString
    "Description of the product (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    name: String!
    "Represents an individual item for sale in the storefront."
    product: Product @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    seoDescription: String
    seoTitle: String
    "Returns translated product fields for the given language code."
    translation(
        "A language code to return the translation for product."
        languageCode: LanguageCodeEnum!
    ): ProductTranslation
}

"Creates/updates translations for a product."
type ProductTranslate {
    errors: [TranslationError!]!
    product: Product
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductTranslation implements Node {
    description: JSONString
    "Translated description of the product (JSON)."
    descriptionJson: JSONString @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `description` field instead.")
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
    seoDescription: String
    seoTitle: String
}

"Represents a type of product. It defines what attributes are available to products of this type."
type ProductType implements Node & ObjectWithMetadata {
    "New in Saleor 3.1. Variant attributes of that product type with attached variant selection."
    assignedVariantAttributes(
        "Define scope of returned attributes."
        variantSelection: VariantAttributeScope
    ): [AssignedVariantAttribute]
    availableAttributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): AttributeCountableConnection
    hasVariants: Boolean!
    id: ID!
    isDigital: Boolean!
    isShippingRequired: Boolean!
    "The product type kind."
    kind: ProductTypeKindEnum!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Product attributes of that product type."
    productAttributes: [Attribute]
    "List of products of this type."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection @deprecated(reason: "This field will be removed in Saleor 4.0. Use the top-level `products` query with the `productTypes` filter.")
    slug: String!
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "Variant attributes of that product type."
    variantAttributes(
        "Define scope of returned attributes."
        variantSelection: VariantAttributeScope
    ): [Attribute] @deprecated(reason: "This field will be removed in Saleor 4.0. Use `assignedVariantAttributes` instead.")
    weight: Weight
}

"Deletes product types."
type ProductTypeBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductTypeCountableConnection {
    edges: [ProductTypeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductTypeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductType!
}

"Creates a new product type."
type ProductTypeCreate {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productType: ProductType
}

"Deletes a product type."
type ProductTypeDelete {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productType: ProductType
}

"Reorder the attributes of a product type."
type ProductTypeReorderAttributes {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Product type from which attributes are reordered."
    productType: ProductType
}

"Updates an existing product type."
type ProductTypeUpdate {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productType: ProductType
}

"Updates an existing product."
type ProductUpdate {
    errors: [ProductError!]!
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents a version of a product such as different size or color."
type ProductVariant implements Node & ObjectWithMetadata {
    "List of attributes assigned to this variant."
    attributes(
        "Define scope of returned attributes."
        variantSelection: VariantAttributeScope
    ): [SelectedAttribute!]!
    "Channel given to retrieve this product variant. Also used by federation gateway to resolve this object in a federated query."
    channel: String
    "List of price information in channels for the product."
    channelListings: [ProductVariantChannelListing!]
    created: DateTime!
    "Digital content for the product variant."
    digitalContent: DigitalContent
    id: ID!
    "List of images for the product variant."
    images: [ProductImage] @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `media` field instead.")
    "Gross margin percentage value."
    margin: Int
    "List of media for the product variant."
    media: [ProductMedia!]
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "New in Saleor 3.1. Preorder data for product variant. Note: this feature is in a preview state and can be subject to changes at later point."
    preorder: PreorderData
    "Lists the storefront variant's pricing, the current price and discounts, only meant for displaying."
    pricing(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput
    ): VariantPricingInfo
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    product: Product!
    "Quantity of a product available for sale in one checkout. Field value will be `null` when no `limitQuantityPerCheckout` in global settings has been set, and `productVariant` stocks are not tracked."
    quantityAvailable(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput,
        """

        Two-letter ISO 3166-1 country code. When provided, the exact quantity from a warehouse operating in shipping zones that contain this country will be returned. Otherwise, it will return the maximum quantity from all shipping zones.

        DEPRECATED: this field will be removed in Saleor 4.0. Use `address` argument instead.
        """
        countryCode: CountryCode
    ): Int
    quantityLimitPerCustomer: Int
    "Total quantity ordered."
    quantityOrdered: Int
    "Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations."
    revenue(period: ReportingPeriod): TaxedMoney
    sku: String
    "Stocks for the product variant."
    stocks(
        "Destination address used to find warehouses where stock availability for this product is checked. If address is empty, uses `Shop.companyAddress` or fallbacks to server's `settings.DEFAULT_COUNTRY` configuration."
        address: AddressInput,
        """

        Two-letter ISO 3166-1 country code.

        DEPRECATED: this field will be removed in Saleor 4.0. Use `address` argument instead.
        """
        countryCode: CountryCode
    ): [Stock]
    trackInventory: Boolean!
    "Returns translated product variant fields for the given language code."
    translation(
        "A language code to return the translation for product variant."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslation
    updatedAt: DateTime!
    weight: Weight
}

"Creates product variants for a given product."
type ProductVariantBulkCreate {
    bulkProductErrors: [BulkProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were created."
    count: Int!
    errors: [BulkProductError!]!
    "List of the created variants."
    productVariants: [ProductVariant!]!
}

"Deletes product variants."
type ProductVariantBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents product varaint channel listing."
type ProductVariantChannelListing implements Node {
    channel: Channel!
    "Cost price of the variant."
    costPrice: Money
    id: ID!
    "Gross margin percentage value."
    margin: Int
    "New in Saleor 3.1. Preorder variant data. Note: this feature is in a preview state and can be subject to changes at later point."
    preorderThreshold: PreorderThreshold
    price: Money
}

"Manage product variant prices in channels."
type ProductVariantChannelListingUpdate {
    errors: [ProductChannelListingError!]!
    productChannelListingErrors: [ProductChannelListingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "An updated product variant instance."
    variant: ProductVariant
}

type ProductVariantCountableConnection {
    edges: [ProductVariantCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductVariantCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductVariant!
}

"Creates a new variant for a product."
type ProductVariantCreate {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productVariant: ProductVariant
}

"Deletes a product variant."
type ProductVariantDelete {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productVariant: ProductVariant
}

"New in Saleor 3.1. Deactivates product variant preorder. It changes all preorder allocation into regular allocation. Note: this feature is in a preview state and can be subject to changes at later point."
type ProductVariantPreorderDeactivate {
    errors: [ProductError!]!
    "Product variant with ended preorder."
    productVariant: ProductVariant
}

"Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook."
type ProductVariantReorder {
    errors: [ProductError!]!
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Reorder product variant attribute values."
type ProductVariantReorderAttributeValues {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Product variant from which attribute values are reordered."
    productVariant: ProductVariant
}

"Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook."
type ProductVariantSetDefault {
    errors: [ProductError!]!
    product: Product
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Creates stocks for product variant."
type ProductVariantStocksCreate {
    bulkStockErrors: [BulkStockError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [BulkStockError!]!
    "Updated product variant."
    productVariant: ProductVariant
}

"Delete stocks from product variant."
type ProductVariantStocksDelete {
    errors: [StockError!]!
    "Updated product variant."
    productVariant: ProductVariant
    stockErrors: [StockError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Update stocks for product variant."
type ProductVariantStocksUpdate {
    bulkStockErrors: [BulkStockError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [BulkStockError!]!
    "Updated product variant."
    productVariant: ProductVariant
}

type ProductVariantTranslatableContent implements Node {
    "List of product variant attribute values that can be translated."
    attributeValues: [AttributeValueTranslatableContent!]!
    id: ID!
    name: String!
    "Represents a version of a product such as different size or color."
    productVariant: ProductVariant @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    "Returns translated product variant fields for the given language code."
    translation(
        "A language code to return the translation for product variant."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslation
}

"Creates/updates translations for a product variant."
type ProductVariantTranslate {
    errors: [TranslationError!]!
    productVariant: ProductVariant
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ProductVariantTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates an existing variant for product."
type ProductVariantUpdate {
    errors: [ProductError!]!
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productVariant: ProductVariant
}

type Query {
    _entities(representations: [_Any]): [_Entity]
    _service: _Service
    "Look up an address by ID."
    address(
        "ID of an address."
        id: ID!
    ): Address
    "Returns address validation rules."
    addressValidationRules(
        "City or a town name."
        city: String,
        "Sublocality like a district."
        cityArea: String,
        "Designation of a region, province or state."
        countryArea: String,
        "Two-letter ISO 3166-1 country code."
        countryCode: CountryCode!
    ): AddressValidationData
    "Look up an app by ID. If ID is not provided, return the currently authenticated app."
    app(
        "ID of the app."
        id: ID
    ): App
    "New in Saleor 3.1. Look up an app extension by ID. Note: this feature is in a preview state and can be subject to changes at later point."
    appExtension(
        "ID of the app extension."
        id: ID!
    ): AppExtension
    "New in Saleor 3.1. List of all extensions. Note: this feature is in a preview state and can be subject to changes at later point."
    appExtensions(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for apps extensions."
        filter: AppExtensionFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): AppExtensionCountableConnection
    "List of the apps."
    apps(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for apps."
        filter: AppFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort apps."
        sortBy: AppSortingInput
    ): AppCountableConnection
    "List of all apps installations"
    appsInstallations: [AppInstallation!]!
    "Look up an attribute by ID."
    attribute(
        "ID of the attribute."
        id: ID,
        "Slug of the attribute."
        slug: String
    ): Attribute
    "List of the shop's attributes."
    attributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for attributes."
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sorting options for attributes."
        sortBy: AttributeSortingInput
    ): AttributeCountableConnection
    "List of the shop's categories."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for categories."
        filter: CategoryFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Filter categories by the nesting level in the category tree."
        level: Int,
        "Sort categories."
        sortBy: CategorySortingInput
    ): CategoryCountableConnection
    "Look up a category by ID or slug."
    category(
        "ID of the category."
        id: ID,
        "Slug of the category"
        slug: String
    ): Category
    "Look up a channel by ID."
    channel(
        "ID of the channel."
        id: ID
    ): Channel
    "List of all channels."
    channels: [Channel!]
    "Look up a checkout by token and slug of channel."
    checkout(
        "The checkout's token."
        token: UUID
    ): Checkout
    "List of checkout lines."
    checkoutLines(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CheckoutLineCountableConnection
    "List of checkouts."
    checkouts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "New in Saleor 3.1. Filtering options for checkouts."
        filter: CheckoutFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "New in Saleor 3.1. Sort checkouts."
        sortBy: CheckoutSortingInput
    ): CheckoutCountableConnection
    "Look up a collection by ID."
    collection(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the collection."
        id: ID,
        "Slug of the category"
        slug: String
    ): Collection
    "List of the shop's collections."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for collections."
        filter: CollectionFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort collections."
        sortBy: CollectionSortingInput
    ): CollectionCountableConnection
    "List of the shop's customers."
    customers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for customers."
        filter: CustomerFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort customers."
        sortBy: UserSortingInput
    ): UserCountableConnection
    "Look up digital content by ID."
    digitalContent(
        "ID of the digital content."
        id: ID!
    ): DigitalContent
    "List of digital content."
    digitalContents(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): DigitalContentCountableConnection
    "List of draft orders."
    draftOrders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for draft orders."
        filter: OrderDraftFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort draft orders."
        sortBy: OrderSortingInput
    ): OrderCountableConnection
    "Look up a export file by ID."
    exportFile(
        "ID of the export file job."
        id: ID!
    ): ExportFile
    "List of export files."
    exportFiles(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for export files."
        filter: ExportFileFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort export files."
        sortBy: ExportFileSortingInput
    ): ExportFileCountableConnection
    "Look up a gift card by ID."
    giftCard(
        "ID of the gift card."
        id: ID!
    ): GiftCard
    "New in Saleor 3.1. List of gift card currencies. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardCurrencies: [String!]!
    "Gift card related settings from site settings."
    giftCardSettings: GiftCardSettings!
    "New in Saleor 3.1. List of gift card tags. Note: this feature is in a preview state and can be subject to changes at later point."
    giftCardTags(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for gift card tags."
        filter: GiftCardTagFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): GiftCardTagCountableConnection
    "List of gift cards."
    giftCards(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "New in Saleor 3.1. Filtering options for gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
        filter: GiftCardFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "New in Saleor 3.1. Sort gift cards. Note: this feature is in a preview state and can be subject to changes at later point."
        sortBy: GiftCardSortingInput
    ): GiftCardCountableConnection
    "List of activity events to display on homepage (at the moment it only contains order-events)."
    homepageEvents(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): OrderEventCountableConnection
    "Return the currently authenticated user."
    me: User
    "Look up a navigation menu by ID or name."
    menu(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the menu."
        id: ID,
        "The menu's name."
        name: String,
        "The menu's slug."
        slug: String
    ): Menu
    "Look up a menu item by ID."
    menuItem(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the menu item."
        id: ID!
    ): MenuItem
    "List of the storefronts's menu items."
    menuItems(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for menu items."
        filter: MenuItemFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort menus items."
        sortBy: MenuItemSortingInput
    ): MenuItemCountableConnection
    "List of the storefront's menus."
    menus(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for menus."
        filter: MenuFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort menus."
        sortBy: MenuSortingInput
    ): MenuCountableConnection
    "Look up an order by ID."
    order(
        "ID of an order."
        id: ID!
    ): Order
    "Look up an order by token."
    orderByToken(
        "The order's token."
        token: UUID!
    ): Order
    "Order related settings from site settings."
    orderSettings: OrderSettings
    "List of orders."
    orders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for orders."
        filter: OrderFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort orders."
        sortBy: OrderSortingInput
    ): OrderCountableConnection
    "Return the total sales amount from a specific period."
    ordersTotal(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "A period of time."
        period: ReportingPeriod
    ): TaxedMoney
    "Look up a page by ID or slug."
    page(
        "ID of the page."
        id: ID,
        "The slug of the page."
        slug: String
    ): Page
    "Look up a page type by ID."
    pageType(
        "ID of the page type."
        id: ID!
    ): PageType
    "List of the page types."
    pageTypes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for page types."
        filter: PageTypeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort page types."
        sortBy: PageTypeSortingInput
    ): PageTypeCountableConnection
    "List of the shop's pages."
    pages(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for pages."
        filter: PageFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort pages."
        sortBy: PageSortingInput
    ): PageCountableConnection
    "Look up a payment by ID."
    payment(
        "ID of the payment."
        id: ID!
    ): Payment
    "List of payments."
    payments(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for payments."
        filter: PaymentFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): PaymentCountableConnection
    "Look up permission group by ID."
    permissionGroup(
        "ID of the group."
        id: ID!
    ): Group
    "List of permission groups."
    permissionGroups(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for permission groups."
        filter: PermissionGroupFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort permission groups."
        sortBy: PermissionGroupSortingInput
    ): GroupCountableConnection
    "Look up a plugin by ID."
    plugin(
        "ID of the plugin."
        id: ID!
    ): Plugin
    "List of plugins."
    plugins(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for plugins."
        filter: PluginFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort plugins."
        sortBy: PluginSortingInput
    ): PluginCountableConnection
    "Look up a product by ID."
    product(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the product."
        id: ID,
        "Slug of the product."
        slug: String
    ): Product
    "Look up a product type by ID."
    productType(
        "ID of the product type."
        id: ID!
    ): ProductType
    "List of the shop's product types."
    productTypes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for product types."
        filter: ProductTypeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort product types."
        sortBy: ProductTypeSortingInput
    ): ProductTypeCountableConnection
    "Look up a product variant by ID or SKU."
    productVariant(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the product variant."
        id: ID,
        "Sku of the product variant."
        sku: String
    ): ProductVariant
    "List of product variants."
    productVariants(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for product variant."
        filter: ProductVariantFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Filter product variants by given IDs."
        ids: [ID],
        "Return the last n elements from the list."
        last: Int
    ): ProductVariantCountableConnection
    "List of the shop's products."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for products."
        filter: ProductFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort products."
        sortBy: ProductOrder
    ): ProductCountableConnection
    "List of top selling products."
    reportProductSales(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String!,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Span of time."
        period: ReportingPeriod!
    ): ProductVariantCountableConnection
    "Look up a sale by ID."
    sale(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the sale."
        id: ID!
    ): Sale
    "List of the shop's sales."
    sales(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for sales."
        filter: SaleFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        """

        Search sales by name, value or type.

        DEPRECATED: this field will be removed in Saleor 4.0. Use `filter.search` input instead.
        """
        query: String,
        "Sort sales."
        sortBy: SaleSortingInput
    ): SaleCountableConnection
    "Look up a shipping zone by ID."
    shippingZone(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the shipping zone."
        id: ID!
    ): ShippingZone
    "List of the shop's shipping zones."
    shippingZones(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for shipping zones."
        filter: ShippingZoneFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ShippingZoneCountableConnection
    "Return information about the shop."
    shop: Shop!
    "List of the shop's staff users."
    staffUsers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for staff users."
        filter: StaffUserInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort staff users."
        sortBy: UserSortingInput
    ): UserCountableConnection
    "Look up a stock by ID"
    stock(
        "ID of an warehouse"
        id: ID!
    ): Stock
    "List of stocks."
    stocks(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: StockFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): StockCountableConnection
    "List of all tax rates available from tax gateway."
    taxTypes: [TaxType]
    translation(
        "ID of the object to retrieve."
        id: ID!,
        "Kind of the object to retrieve."
        kind: TranslatableKinds!
    ): TranslatableItem
    "Returns a list of all translatable items of a given kind."
    translations(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Kind of objects to retrieve."
        kind: TranslatableKinds!,
        "Return the last n elements from the list."
        last: Int
    ): TranslatableItemConnection
    "Look up a user by ID or email address."
    user(
        "Email address of the user."
        email: String,
        "ID of the user."
        id: ID
    ): User
    "Look up a voucher by ID."
    voucher(
        "Slug of a channel for which the data should be returned."
        channel: String,
        "ID of the voucher."
        id: ID!
    ): Voucher
    "List of the shop's vouchers."
    vouchers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Slug of a channel for which the data should be returned."
        channel: String,
        "Filtering options for vouchers."
        filter: VoucherFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        """

        Search vouchers by name or code.

        DEPRECATED: this field will be removed in Saleor 4.0. Use `filter.search` input instead.
        """
        query: String,
        "Sort voucher."
        sortBy: VoucherSortingInput
    ): VoucherCountableConnection
    "Look up a warehouse by ID."
    warehouse(
        "ID of an warehouse"
        id: ID!
    ): Warehouse
    "List of warehouses."
    warehouses(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: WarehouseFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        sortBy: WarehouseSortingInput
    ): WarehouseCountableConnection
    "Look up a webhook by ID."
    webhook(
        "ID of the webhook."
        id: ID!
    ): Webhook
    "List of all available webhook events."
    webhookEvents: [WebhookEvent] @deprecated(reason: "This field will be removed in Saleor 4.0. Use `WebhookEventTypeAsyncEnum` and `WebhookEventTypeSyncEnum` to get available event types.")
    "Retrieve a sample payload for a given webhook event based on real data. It can be useful for some integrations where sample payload is required."
    webhookSamplePayload(
        "Name of the requested event type."
        eventType: WebhookSampleEventTypeEnum!
    ): JSONString
}

"Represents a reduced VAT rate for a particular type of goods."
type ReducedRate {
    "Reduced VAT rate in percent."
    rate: Float!
    "A type of goods."
    rateType: String!
}

"Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie."
type RefreshToken {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

"Request email change of the logged in user."
type RequestEmailChange {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "A user instance."
    user: User
}

"Sends an email with the account password modification link."
type RequestPasswordReset {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
}

"Sales allow creating discounts for categories, collections or products and are visible to all the customers."
type Sale implements Node & ObjectWithMetadata {
    "List of categories this sale applies to."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    "List of channels available for the sale."
    channelListings: [SaleChannelListing!]
    "List of collections this sale applies to."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CollectionCountableConnection
    created: DateTime!
    "Currency code for sale."
    currency: String
    "Sale value."
    discountValue: Float
    endDate: DateTime
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products this sale applies to."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    startDate: DateTime!
    "Returns translated sale fields for the given language code."
    translation(
        "A language code to return the translation for sale."
        languageCode: LanguageCodeEnum!
    ): SaleTranslation
    type: SaleType!
    updatedAt: DateTime!
    "New in Saleor 3.1. List of product variants this sale applies to."
    variants(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductVariantCountableConnection
}

"Adds products, categories, collections to a voucher."
type SaleAddCatalogues {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "Sale of which catalogue IDs will be modified."
    sale: Sale
}

"Deletes sales."
type SaleBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
}

"Represents sale channel listing."
type SaleChannelListing implements Node {
    channel: Channel!
    currency: String!
    discountValue: Float!
    id: ID!
}

"Manage sale's availability in channels."
type SaleChannelListingUpdate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "An updated sale instance."
    sale: Sale
}

type SaleCountableConnection {
    edges: [SaleCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type SaleCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Sale!
}

"Creates a new sale."
type SaleCreate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    sale: Sale
}

"Deletes a sale."
type SaleDelete {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    sale: Sale
}

"Removes products, categories, collections from a sale."
type SaleRemoveCatalogues {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "Sale of which catalogue IDs will be modified."
    sale: Sale
}

type SaleTranslatableContent implements Node {
    id: ID!
    name: String!
    "Sales allow creating discounts for categories, collections or products and are visible to all the customers."
    sale: Sale @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    "Returns translated sale fields for the given language code."
    translation(
        "A language code to return the translation for sale."
        languageCode: LanguageCodeEnum!
    ): SaleTranslation
}

"Creates/updates translations for a sale."
type SaleTranslate {
    errors: [TranslationError!]!
    sale: Sale
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type SaleTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Updates a sale."
type SaleUpdate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    sale: Sale
}

"Represents a custom attribute."
type SelectedAttribute {
    "Name of an attribute displayed in the interface."
    attribute: Attribute!
    "Values of an attribute."
    values: [AttributeValue]!
}

"Sets the user's password from the token sent by email using the RequestPasswordReset mutation."
type SetPassword {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "CSRF token required to re-generate access token."
    csrfToken: String
    errors: [AccountError!]!
    "JWT refresh token, required to re-generate access token."
    refreshToken: String
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

type ShippingError {
    "List of channels IDs which causes the error."
    channels: [ID!]
    "The error code."
    code: ShippingErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of warehouse IDs which causes the error."
    warehouses: [ID!]
}

"Shipping methods that can be used as means of shipping for orders and checkouts."
type ShippingMethod implements Node & ObjectWithMetadata {
    "Describes if this shipping method is active and can be selected."
    active: Boolean!
    "Shipping method description (JSON)."
    description: JSONString
    "Unique ID of ShippingMethod available for Order."
    id: ID!
    "Maximum delivery days for this shipping method."
    maximumDeliveryDays: Int
    "Maximum order price for this shipping method."
    maximumOrderPrice: Money
    "Maximum order weight for this shipping method."
    maximumOrderWeight: Weight @deprecated(reason: "This field will be removed in Saleor 4.0.")
    "Message connected to this shipping method."
    message: String
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Minimum delivery days for this shipping method."
    minimumDeliveryDays: Int
    "Minimal order price for this shipping method."
    minimumOrderPrice: Money
    "Minimum order weight for this shipping method."
    minimumOrderWeight: Weight @deprecated(reason: "This field will be removed in Saleor 4.0.")
    "Shipping method name."
    name: String!
    "The price of selected shipping method."
    price: Money!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
    "Type of the shipping method."
    type: ShippingMethodTypeEnum @deprecated(reason: "This field will be removed in Saleor 4.0.")
}

"Represents shipping method channel listing."
type ShippingMethodChannelListing implements Node {
    channel: Channel!
    id: ID!
    maximumOrderPrice: Money
    minimumOrderPrice: Money
    price: Money
}

"Manage shipping method's availability in channels."
type ShippingMethodChannelListingUpdate {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "An updated shipping method instance."
    shippingMethod: ShippingMethodType
}

"Represents shipping method postal code rule."
type ShippingMethodPostalCodeRule implements Node {
    "End address range."
    end: String
    "The ID of the object."
    id: ID!
    "Inclusion type of the postal code rule."
    inclusionType: PostalCodeRuleInclusionTypeEnum
    "Start address range."
    start: String
}

type ShippingMethodTranslatableContent implements Node {
    description: JSONString
    id: ID!
    name: String!
    "Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers."
    shippingMethod: ShippingMethodType @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
}

type ShippingMethodTranslation implements Node {
    description: JSONString
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers."
type ShippingMethodType implements Node & ObjectWithMetadata {
    "List of channels available for the method."
    channelListings: [ShippingMethodChannelListing!]
    "Shipping method description."
    description: JSONString
    "List of excluded products for the shipping method."
    excludedProducts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    "Shipping method ID."
    id: ID!
    "Maximum number of days for delivery."
    maximumDeliveryDays: Int
    "The price of the cheapest variant (including discounts)."
    maximumOrderPrice: Money
    "Maximum order weight to use this shipping method."
    maximumOrderWeight: Weight
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Minimal number of days for delivery."
    minimumDeliveryDays: Int
    "The price of the cheapest variant (including discounts)."
    minimumOrderPrice: Money
    "Minimum order weight to use this shipping method."
    minimumOrderWeight: Weight
    "Shipping method name."
    name: String!
    "Postal code ranges rule of exclusion or inclusion of the shipping method."
    postalCodeRules: [ShippingMethodPostalCodeRule]
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
    "Type of the shipping method."
    type: ShippingMethodTypeEnum
}

"Deletes shipping prices."
type ShippingPriceBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Creates a new shipping price."
type ShippingPriceCreate {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    shippingMethod: ShippingMethodType
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Deletes a shipping price."
type ShippingPriceDelete {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "A shipping method to delete."
    shippingMethod: ShippingMethodType
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Exclude products from shipping price."
type ShippingPriceExcludeProducts {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "A shipping method with new list of excluded products."
    shippingMethod: ShippingMethodType
}

"Remove product from excluded list for shipping price."
type ShippingPriceRemoveProductFromExclude {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "A shipping method with new list of excluded products."
    shippingMethod: ShippingMethodType
}

"Creates/updates translations for a shipping method."
type ShippingPriceTranslate {
    errors: [TranslationError!]!
    shippingMethod: ShippingMethodType
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates a new shipping price."
type ShippingPriceUpdate {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    shippingMethod: ShippingMethodType
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly."
type ShippingZone implements Node & ObjectWithMetadata {
    "List of channels for shipping zone."
    channels: [Channel!]!
    "List of countries available for the method."
    countries: [CountryDisplay]
    default: Boolean!
    "Description of a shipping zone."
    description: String
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Lowest and highest prices for the shipping."
    priceRange: MoneyRange
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of shipping methods available for orders shipped to countries within this shipping zone."
    shippingMethods: [ShippingMethodType]
    "List of warehouses for shipping zone."
    warehouses: [Warehouse!]!
}

"Deletes shipping zones."
type ShippingZoneBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ShippingZoneCountableConnection {
    edges: [ShippingZoneCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ShippingZoneCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShippingZone!
}

"Creates a new shipping zone."
type ShippingZoneCreate {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    shippingZone: ShippingZone
}

"Deletes a shipping zone."
type ShippingZoneDelete {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    shippingZone: ShippingZone
}

"Updates a new shipping zone."
type ShippingZoneUpdate {
    errors: [ShippingError!]!
    shippingErrors: [ShippingError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    shippingZone: ShippingZone
}

"Represents a shop resource containing general shop data and configuration."
type Shop {
    "Enable automatic fulfillment for all digital products."
    automaticFulfillmentDigitalProducts: Boolean
    "List of available external authentications."
    availableExternalAuthentications: [ExternalAuthentication!]!
    "List of available payment gateways."
    availablePaymentGateways(
        "Slug of a channel for which the data should be returned."
        channel: String,
        """

        A currency for which gateways will be returned.

        DEPRECATED: this field will be removed in Saleor 4.0. Use `channel` argument instead.
        """
        currency: String
    ): [PaymentGateway!]!
    "Shipping methods that are available for the shop."
    availableShippingMethods(
        "Address for which available shipping methods should be returned."
        address: AddressInput,
        "Slug of a channel for which the data should be returned."
        channel: String!
    ): [ShippingMethod]
    "New in Saleor 3.1. List of all currencies supported by shop's channels."
    channelCurrencies: [String!]!
    "Charge taxes on shipping."
    chargeTaxesOnShipping: Boolean!
    "Company address."
    companyAddress: Address
    "List of countries available in the shop."
    countries(
        "Filtering options for countries"
        filter: CountryFilterInput,
        """

        A language code to return the translation for.

        DEPRECATED: this field will be removed in Saleor 4.0.
        """
        languageCode: LanguageCodeEnum
    ): [CountryDisplay!]!
    "URL of a view where customers can set their password."
    customerSetPasswordUrl: String
    "Shop's default country."
    defaultCountry: CountryDisplay
    "Default number of max downloads per digital content URL."
    defaultDigitalMaxDownloads: Int
    "Default number of days which digital content URL will be valid."
    defaultDigitalUrlValidDays: Int
    "Default shop's email sender's address."
    defaultMailSenderAddress: String
    "Default shop's email sender's name."
    defaultMailSenderName: String
    "Default weight unit."
    defaultWeightUnit: WeightUnitsEnum
    "Shop's description."
    description: String
    "Display prices with tax in store."
    displayGrossPrices: Boolean!
    "Shop's domain data."
    domain: Domain!
    "New in Saleor 3.1. Allow to approve fulfillments which are unpaid."
    fulfillmentAllowUnpaid: Boolean!
    "New in Saleor 3.1. Automatically approve all new fulfillments."
    fulfillmentAutoApprove: Boolean!
    "Header text."
    headerText: String
    "Include taxes in prices."
    includeTaxesInPrices: Boolean!
    "List of the shops's supported languages."
    languages: [LanguageDisplay]!
    "New in Saleor 3.1. Default number of maximum line quantity in single checkout (per single checkout line). Note: this feature is in a preview state and can be subject to changes at later point."
    limitQuantityPerCheckout: Int
    "Resource limitations and current usage if any set for a shop"
    limits: LimitInfo!
    "Shop's name."
    name: String!
    "List of available permissions."
    permissions: [Permission]!
    "List of possible phone prefixes."
    phonePrefixes: [String]!
    "New in Saleor 3.1. Default number of minutes stock will be reserved for anonymous checkout or null when stock reservation is disabled."
    reserveStockDurationAnonymousUser: Int
    "New in Saleor 3.1. Default number of minutes stock will be reserved for authenticated checkout or null when stock reservation is disabled."
    reserveStockDurationAuthenticatedUser: Int
    "List of staff notification recipients."
    staffNotificationRecipients: [StaffNotificationRecipient]
    "Enable inventory tracking."
    trackInventoryByDefault: Boolean
    "Returns translated shop fields for the given language code."
    translation(
        "A language code to return the translation for shop."
        languageCode: LanguageCodeEnum!
    ): ShopTranslation
    "Saleor API version."
    version: String!
}

"Update the shop's address. If the `null` value is passed, the currently selected address will be deleted."
type ShopAddressUpdate {
    errors: [ShopError!]!
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates site domain of the shop."
type ShopDomainUpdate {
    errors: [ShopError!]!
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ShopError {
    "The error code."
    code: ShopErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Fetch tax rates."
type ShopFetchTaxRates {
    errors: [ShopError!]!
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Creates/updates translations for shop settings."
type ShopSettingsTranslate {
    errors: [TranslationError!]!
    "Updated shop settings."
    shop: Shop
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates shop settings."
type ShopSettingsUpdate {
    errors: [ShopError!]!
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type ShopTranslation implements Node {
    description: String!
    headerText: String!
    id: ID!
    "Translation language."
    language: LanguageDisplay!
}

"Deletes staff users."
type StaffBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    errors: [StaffError!]!
    staffErrors: [StaffError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Creates a new staff user."
type StaffCreate {
    errors: [StaffError!]!
    staffErrors: [StaffError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    user: User
}

"Deletes a staff user."
type StaffDelete {
    errors: [StaffError!]!
    staffErrors: [StaffError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    user: User
}

type StaffError {
    "A type of address that causes the error."
    addressType: AddressTypeEnum
    "The error code."
    code: AccountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "List of permission group IDs which cause the error."
    groups: [ID!]
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
    "List of user IDs which causes the error."
    users: [ID!]
}

"Represents a recipient of email notifications send by Saleor, such as notifications about new orders. Notifications can be assigned to staff users or arbitrary email addresses."
type StaffNotificationRecipient implements Node {
    "Determines if a notification active."
    active: Boolean
    "Returns email address of a user subscribed to email notifications."
    email: String
    id: ID!
    "Returns a user subscribed to email notifications."
    user: User
}

"Creates a new staff notification recipient."
type StaffNotificationRecipientCreate {
    errors: [ShopError!]!
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    staffNotificationRecipient: StaffNotificationRecipient
}

"Delete staff notification recipient."
type StaffNotificationRecipientDelete {
    errors: [ShopError!]!
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    staffNotificationRecipient: StaffNotificationRecipient
}

"Updates a staff notification recipient."
type StaffNotificationRecipientUpdate {
    errors: [ShopError!]!
    shopErrors: [ShopError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    staffNotificationRecipient: StaffNotificationRecipient
}

"Updates an existing staff user."
type StaffUpdate {
    errors: [StaffError!]!
    staffErrors: [StaffError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    user: User
}

"Represents stock."
type Stock implements Node {
    id: ID!
    productVariant: ProductVariant!
    "Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment."
    quantity: Int!
    "Quantity allocated for orders"
    quantityAllocated: Int!
    "Quantity reserved for checkouts"
    quantityReserved: Int!
    warehouse: Warehouse!
}

type StockCountableConnection {
    edges: [StockCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type StockCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Stock!
}

type StockError {
    "The error code."
    code: StockErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Representation of tax types fetched from tax gateway."
type TaxType {
    "Description of the tax type."
    description: String
    "External tax code used to identify given tax group."
    taxCode: String
}

"Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal."
type TaxedMoney {
    "Currency code."
    currency: String!
    "Amount of money including taxes."
    gross: Money!
    "Amount of money without taxes."
    net: Money!
    "Amount of taxes."
    tax: Money!
}

"Represents a range of monetary values."
type TaxedMoneyRange {
    "Lower bound of a price range."
    start: TaxedMoney
    "Upper bound of a price range."
    stop: TaxedMoney
}

type TimePeriod {
    "The length of the period."
    amount: Int!
    "The type of the period."
    type: TimePeriodTypeEnum!
}

"An object representing a single payment."
type Transaction implements Node {
    "Total amount of the transaction."
    amount: Money
    created: DateTime!
    error: String
    gatewayResponse: JSONString!
    id: ID!
    isSuccess: Boolean!
    kind: TransactionKind!
    payment: Payment!
    token: String!
}

type TranslatableItemConnection {
    edges: [TranslatableItemEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type TranslatableItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TranslatableItem!
}

type TranslationError {
    "The error code."
    code: TranslationErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Updates metadata of an object."
type UpdateMetadata {
    errors: [MetadataError!]!
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates private metadata of an object."
type UpdatePrivateMetadata {
    errors: [MetadataError!]!
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type UploadError {
    "The error code."
    code: UploadErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Represents user data."
type User implements Node & ObjectWithMetadata {
    "List of all user's addresses."
    addresses: [Address]
    avatar(
        "Size of the avatar."
        size: Int
    ): Image
    "Returns the last open checkout of this user."
    checkout: Checkout @deprecated(reason: "This field will be removed in Saleor 4.0. Use the `checkout_tokens` field to fetch the user checkouts.")
    "Returns the checkout UUID's assigned to this user."
    checkoutTokens(
        "Slug of a channel for which the data should be returned."
        channel: String
    ): [UUID!]
    dateJoined: DateTime!
    defaultBillingAddress: Address
    defaultShippingAddress: Address
    "List of user's permission groups which user can manage."
    editableGroups: [Group]
    email: String!
    "List of events associated with the user."
    events: [CustomerEvent]
    firstName: String!
    "List of the user gift cards."
    giftCards(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): GiftCardCountableConnection
    id: ID!
    isActive: Boolean!
    isStaff: Boolean!
    "User language code."
    languageCode: LanguageCodeEnum!
    lastLogin: DateTime
    lastName: String!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "A note about the customer."
    note: String
    "List of user's orders."
    orders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): OrderCountableConnection
    "List of user's permission groups."
    permissionGroups: [Group]
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of stored payment sources."
    storedPaymentSources(
        "Slug of a channel for which the data should be returned."
        channel: String
    ): [PaymentSource]
    updatedAt: DateTime!
    "List of user's permissions."
    userPermissions: [UserPermission]
}

"Deletes a user avatar. Only for staff members."
type UserAvatarDelete {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "An updated user instance."
    user: User
}

"Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type UserAvatarUpdate {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "An updated user instance."
    user: User
}

"Activate or deactivate users."
type UserBulkSetActive {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    "Returns how many objects were affected."
    count: Int!
    errors: [AccountError!]!
}

type UserCountableConnection {
    edges: [UserCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type UserCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type UserPermission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
    "List of user permission groups which contains this permission."
    sourcePermissionGroups(
        "ID of user whose groups should be returned."
        userId: ID!
    ): [Group!]
}

"Represents a VAT rate for a country."
type VAT {
    "Country code."
    countryCode: String!
    "Country's VAT rate exceptions for specific types of goods."
    reducedRates: [ReducedRate]!
    "Standard VAT rate in percent."
    standardRate: Float
}

"Assign an media to a product variant."
type VariantMediaAssign {
    errors: [ProductError!]!
    media: ProductMedia
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productVariant: ProductVariant
}

"Unassign an media from a product variant."
type VariantMediaUnassign {
    errors: [ProductError!]!
    media: ProductMedia
    productErrors: [ProductError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    productVariant: ProductVariant
}

"Represents availability of a variant in the storefront."
type VariantPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The price, with any discount subtracted."
    price: TaxedMoney
    "The discounted price in the local currency."
    priceLocalCurrency: TaxedMoney
    "The price without any discount."
    priceUndiscounted: TaxedMoney
}

"Verify JWT token."
type VerifyToken {
    accountErrors: [AccountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [AccountError!]!
    "Determine if token is valid or not."
    isValid: Boolean!
    "JWT payload."
    payload: GenericScalar
    "User assigned to token."
    user: User
}

"Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes."
type Voucher implements Node & ObjectWithMetadata {
    applyOncePerCustomer: Boolean!
    applyOncePerOrder: Boolean!
    "List of categories this voucher applies to."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    "List of availability in channels for the voucher."
    channelListings: [VoucherChannelListing!]
    code: String!
    "List of collections this voucher applies to."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CollectionCountableConnection
    "List of countries available for the shipping voucher."
    countries: [CountryDisplay]
    "Currency code for voucher."
    currency: String
    "Voucher value."
    discountValue: Float
    "Determines a type of discount for voucher - value or percentage"
    discountValueType: DiscountValueTypeEnum!
    endDate: DateTime
    id: ID!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    minCheckoutItemsQuantity: Int
    "Minimum order value to apply voucher."
    minSpent: Money
    name: String
    onlyForStaff: Boolean!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products this voucher applies to."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    startDate: DateTime!
    "Returns translated voucher fields for the given language code."
    translation(
        "A language code to return the translation for voucher."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslation
    "Determines a type of voucher."
    type: VoucherTypeEnum!
    usageLimit: Int
    used: Int!
    "New in Saleor 3.1. List of product variants this voucher applies to."
    variants(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductVariantCountableConnection
}

"Adds products, categories, collections to a voucher."
type VoucherAddCatalogues {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "Voucher of which catalogue IDs will be modified."
    voucher: Voucher
}

"Deletes vouchers."
type VoucherBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
}

"Represents voucher channel listing."
type VoucherChannelListing implements Node {
    channel: Channel!
    currency: String!
    discountValue: Float!
    id: ID!
    minSpent: Money
}

"Manage voucher's availability in channels."
type VoucherChannelListingUpdate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "An updated voucher instance."
    voucher: Voucher
}

type VoucherCountableConnection {
    edges: [VoucherCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type VoucherCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Voucher!
}

"Creates a new voucher."
type VoucherCreate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    voucher: Voucher
}

"Deletes a voucher."
type VoucherDelete {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    voucher: Voucher
}

"Removes products, categories, collections from a voucher."
type VoucherRemoveCatalogues {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    "Voucher of which catalogue IDs will be modified."
    voucher: Voucher
}

type VoucherTranslatableContent implements Node {
    id: ID!
    name: String
    "Returns translated voucher fields for the given language code."
    translation(
        "A language code to return the translation for voucher."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslation
    "Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes."
    voucher: Voucher @deprecated(reason: "This field will be removed in Saleor 4.0. Get model fields from the root level queries.")
}

"Creates/updates translations for a voucher."
type VoucherTranslate {
    errors: [TranslationError!]!
    translationErrors: [TranslationError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    voucher: Voucher
}

type VoucherTranslation implements Node {
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Updates a voucher."
type VoucherUpdate {
    discountErrors: [DiscountError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
    errors: [DiscountError!]!
    voucher: Voucher
}

"Represents warehouse."
type Warehouse implements Node & ObjectWithMetadata {
    address: Address!
    "New in Saleor 3.1. Click and collect options: local, all or disabled. Note: this feature is in a preview state and can be subject to changes at later point."
    clickAndCollectOption: WarehouseClickAndCollectOptionEnum!
    "Warehouse company name."
    companyName: String! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `Address.companyName` instead.")
    email: String!
    id: ID!
    isPrivate: Boolean!
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    shippingZones(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ShippingZoneCountableConnection!
    slug: String!
}

type WarehouseCountableConnection {
    edges: [WarehouseCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type WarehouseCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Warehouse!
}

"Creates new warehouse."
type WarehouseCreate {
    errors: [WarehouseError!]!
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes selected warehouse."
type WarehouseDelete {
    errors: [WarehouseError!]!
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type WarehouseError {
    "The error code."
    code: WarehouseErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Add shipping zone to given warehouse."
type WarehouseShippingZoneAssign {
    errors: [WarehouseError!]!
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Remove shipping zone from given warehouse."
type WarehouseShippingZoneUnassign {
    errors: [WarehouseError!]!
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Updates given warehouse."
type WarehouseUpdate {
    errors: [WarehouseError!]!
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Webhook."
type Webhook implements Node {
    app: App!
    "List of asynchronous webhook events."
    asyncEvents: [WebhookEventAsync!]!
    "Event deliveries."
    eventDeliveries(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Event delivery filter options."
        filter: EventDeliveryFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Event delivery sorter."
        sortBy: EventDeliverySortingInput
    ): EventDeliveryCountableConnection
    "List of webhook events."
    events: [WebhookEvent!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.")
    id: ID!
    isActive: Boolean!
    name: String!
    secretKey: String
    "List of synchronous webhook events."
    syncEvents: [WebhookEventSync!]!
    targetUrl: String!
}

"Creates a new webhook subscription."
type WebhookCreate {
    errors: [WebhookError!]!
    webhook: Webhook
    webhookErrors: [WebhookError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Deletes a webhook subscription."
type WebhookDelete {
    errors: [WebhookError!]!
    webhook: Webhook
    webhookErrors: [WebhookError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

type WebhookError {
    "The error code."
    code: WebhookErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Webhook event."
type WebhookEvent {
    "Internal name of the event type."
    eventType: WebhookEventTypeEnum!
    "Display name of the event."
    name: String!
}

"Asynchronous webhook event."
type WebhookEventAsync {
    "Internal name of the event type."
    eventType: WebhookEventTypeAsyncEnum!
    "Display name of the event."
    name: String!
}

"Synchronous webhook event."
type WebhookEventSync {
    "Internal name of the event type."
    eventType: WebhookEventTypeSyncEnum!
    "Display name of the event."
    name: String!
}

"Updates a webhook subscription."
type WebhookUpdate {
    errors: [WebhookError!]!
    webhook: Webhook
    webhookErrors: [WebhookError!]! @deprecated(reason: "This field will be removed in Saleor 4.0. Use `errors` field instead.")
}

"Represents weight value in a specific weight unit."
type Weight {
    "Weight unit."
    unit: WeightUnitsEnum!
    "Weight value."
    value: Float!
}

"_Service manifest as defined by Federation spec."
type _Service {
    sdl: String
}

"An enumeration."
enum AccountErrorCode {
    ACCOUNT_NOT_CONFIRMED
    ACTIVATE_OWN_ACCOUNT
    ACTIVATE_SUPERUSER_ACCOUNT
    CHANNEL_INACTIVE
    DEACTIVATE_OWN_ACCOUNT
    DEACTIVATE_SUPERUSER_ACCOUNT
    DELETE_NON_STAFF_USER
    DELETE_OWN_ACCOUNT
    DELETE_STAFF_ACCOUNT
    DELETE_SUPERUSER_ACCOUNT
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INACTIVE
    INVALID
    INVALID_CREDENTIALS
    INVALID_PASSWORD
    JWT_DECODE_ERROR
    JWT_INVALID_CSRF_TOKEN
    JWT_INVALID_TOKEN
    JWT_MISSING_TOKEN
    JWT_SIGNATURE_EXPIRED
    LEFT_NOT_MANAGEABLE_PERMISSION
    MISSING_CHANNEL_SLUG
    NOT_FOUND
    OUT_OF_SCOPE_GROUP
    OUT_OF_SCOPE_PERMISSION
    OUT_OF_SCOPE_USER
    PASSWORD_ENTIRELY_NUMERIC
    PASSWORD_TOO_COMMON
    PASSWORD_TOO_SHORT
    PASSWORD_TOO_SIMILAR
    REQUIRED
    UNIQUE
}

"An enumeration."
enum AddressTypeEnum {
    BILLING
    SHIPPING
}

"An enumeration."
enum AppErrorCode {
    FORBIDDEN
    GRAPHQL_ERROR
    INVALID
    INVALID_MANIFEST_FORMAT
    INVALID_PERMISSION
    INVALID_STATUS
    INVALID_URL_FORMAT
    MANIFEST_URL_CANT_CONNECT
    NOT_FOUND
    OUT_OF_SCOPE_APP
    OUT_OF_SCOPE_PERMISSION
    REQUIRED
    UNIQUE
}

"All places where app extension can be mounted."
enum AppExtensionMountEnum {
    NAVIGATION_CATALOG
    NAVIGATION_CUSTOMERS
    NAVIGATION_DISCOUNTS
    NAVIGATION_ORDERS
    NAVIGATION_PAGES
    NAVIGATION_TRANSLATIONS
    PRODUCT_DETAILS_MORE_ACTIONS
    PRODUCT_OVERVIEW_CREATE
    PRODUCT_OVERVIEW_MORE_ACTIONS
}

"""

All available ways of opening an app extension.

POPUP - app's extension will be mounted as a popup window
APP_PAGE - redirect to app's page
"""
enum AppExtensionTargetEnum {
    APP_PAGE
    POPUP
}

enum AppSortField {
    "Sort apps by creation date."
    CREATION_DATE
    "Sort apps by name."
    NAME
}

"Enum determining type of your App."
enum AppTypeEnum {
    "Local Saleor App. The app is fully manageable from dashboard. You can change assigned permissions, add webhooks, or authentication token"
    LOCAL
    "Third party external App. Installation is fully automated. Saleor uses a defined App manifest to gather all required information."
    THIRDPARTY
}

"An enumeration."
enum AreaUnitsEnum {
    SQ_CM
    SQ_FT
    SQ_INCH
    SQ_KM
    SQ_M
    SQ_YD
}

enum AttributeChoicesSortField {
    "Sort attribute choice by name."
    NAME
    "Sort attribute choice by slug."
    SLUG
}

"An enumeration."
enum AttributeEntityTypeEnum {
    PAGE
    PRODUCT
}

"An enumeration."
enum AttributeErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum AttributeInputTypeEnum {
    BOOLEAN
    DATE
    DATE_TIME
    DROPDOWN
    FILE
    MULTISELECT
    NUMERIC
    REFERENCE
    RICH_TEXT
    SWATCH
}

enum AttributeSortField {
    "Sort attributes based on whether they can be displayed or not in a product grid."
    AVAILABLE_IN_GRID
    "Sort attributes by the filterable in dashboard flag"
    FILTERABLE_IN_DASHBOARD
    "Sort attributes by the filterable in storefront flag"
    FILTERABLE_IN_STOREFRONT
    "Sort attributes by the variant only flag"
    IS_VARIANT_ONLY
    "Sort attributes by name"
    NAME
    "Sort attributes by slug"
    SLUG
    "Sort attributes by their position in storefront"
    STOREFRONT_SEARCH_POSITION
    "Sort attributes by the value required flag"
    VALUE_REQUIRED
    "Sort attributes by visibility in the storefront"
    VISIBLE_IN_STOREFRONT
}

"An enumeration."
enum AttributeTypeEnum {
    PAGE_TYPE
    PRODUCT_TYPE
}

enum CategorySortField {
    "Sort categories by name."
    NAME
    "Sort categories by product count."
    PRODUCT_COUNT
    "Sort categories by subcategory count."
    SUBCATEGORY_COUNT
}

"An enumeration."
enum ChannelErrorCode {
    ALREADY_EXISTS
    CHANNELS_CURRENCY_MUST_BE_THE_SAME
    CHANNEL_WITH_ORDERS
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum CheckoutErrorCode {
    BILLING_ADDRESS_NOT_SET
    CHANNEL_INACTIVE
    CHECKOUT_NOT_FULLY_PAID
    DELIVERY_METHOD_NOT_APPLICABLE
    EMAIL_NOT_SET
    GIFT_CARD_NOT_APPLICABLE
    GRAPHQL_ERROR
    INSUFFICIENT_STOCK
    INVALID
    INVALID_SHIPPING_METHOD
    MISSING_CHANNEL_SLUG
    NOT_FOUND
    NO_LINES
    PAYMENT_ERROR
    PRODUCT_NOT_PUBLISHED
    PRODUCT_UNAVAILABLE_FOR_PURCHASE
    QUANTITY_GREATER_THAN_LIMIT
    REQUIRED
    SHIPPING_ADDRESS_NOT_SET
    SHIPPING_METHOD_NOT_APPLICABLE
    SHIPPING_METHOD_NOT_SET
    SHIPPING_NOT_REQUIRED
    TAX_ERROR
    UNAVAILABLE_VARIANT_IN_CHANNEL
    UNIQUE
    VOUCHER_NOT_APPLICABLE
    ZERO_QUANTITY
}

enum CheckoutSortField {
    "Sort checkouts by creation date."
    CREATION_DATE
    "Sort checkouts by customer."
    CUSTOMER
    "Sort checkouts by payment."
    PAYMENT
}

"An enumeration."
enum CollectionErrorCode {
    CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum CollectionPublished {
    HIDDEN
    PUBLISHED
}

enum CollectionSortField {
    "Sort collections by availability."
    AVAILABILITY
    "Sort collections by name."
    NAME
    "Sort collections by product count."
    PRODUCT_COUNT
    "Sort collections by publication date."
    PUBLICATION_DATE
}

"An enumeration."
enum ConfigurationTypeFieldEnum {
    BOOLEAN
    MULTILINE
    OUTPUT
    PASSWORD
    SECRET
    SECRETMULTILINE
    STRING
}

"An enumeration."
enum CountryCode {
    AD
    AE
    AF
    AG
    AI
    AL
    AM
    AO
    AQ
    AR
    AS
    AT
    AU
    AW
    AX
    AZ
    BA
    BB
    BD
    BE
    BF
    BG
    BH
    BI
    BJ
    BL
    BM
    BN
    BO
    BQ
    BR
    BS
    BT
    BV
    BW
    BY
    BZ
    CA
    CC
    CD
    CF
    CG
    CH
    CI
    CK
    CL
    CM
    CN
    CO
    CR
    CU
    CV
    CW
    CX
    CY
    CZ
    DE
    DJ
    DK
    DM
    DO
    DZ
    EC
    EE
    EG
    EH
    ER
    ES
    ET
    EU
    FI
    FJ
    FK
    FM
    FO
    FR
    GA
    GB
    GD
    GE
    GF
    GG
    GH
    GI
    GL
    GM
    GN
    GP
    GQ
    GR
    GS
    GT
    GU
    GW
    GY
    HK
    HM
    HN
    HR
    HT
    HU
    ID
    IE
    IL
    IM
    IN
    IO
    IQ
    IR
    IS
    IT
    JE
    JM
    JO
    JP
    KE
    KG
    KH
    KI
    KM
    KN
    KP
    KR
    KW
    KY
    KZ
    LA
    LB
    LC
    LI
    LK
    LR
    LS
    LT
    LU
    LV
    LY
    MA
    MC
    MD
    ME
    MF
    MG
    MH
    MK
    ML
    MM
    MN
    MO
    MP
    MQ
    MR
    MS
    MT
    MU
    MV
    MW
    MX
    MY
    MZ
    NA
    NC
    NE
    NF
    NG
    NI
    NL
    NO
    NP
    NR
    NU
    NZ
    OM
    PA
    PE
    PF
    PG
    PH
    PK
    PL
    PM
    PN
    PR
    PS
    PT
    PW
    PY
    QA
    RE
    RO
    RS
    RU
    RW
    SA
    SB
    SC
    SD
    SE
    SG
    SH
    SI
    SJ
    SK
    SL
    SM
    SN
    SO
    SR
    SS
    ST
    SV
    SX
    SY
    SZ
    TC
    TD
    TF
    TG
    TH
    TJ
    TK
    TL
    TM
    TN
    TO
    TR
    TT
    TV
    TW
    TZ
    UA
    UG
    UM
    US
    UY
    UZ
    VA
    VC
    VE
    VG
    VI
    VN
    VU
    WF
    WS
    YE
    YT
    ZA
    ZM
    ZW
}

"An enumeration."
enum CustomerEventsEnum {
    ACCOUNT_CREATED
    CUSTOMER_DELETED
    DIGITAL_LINK_DOWNLOADED
    EMAIL_ASSIGNED
    EMAIL_CHANGED
    EMAIL_CHANGED_REQUEST
    NAME_ASSIGNED
    NOTE_ADDED
    NOTE_ADDED_TO_ORDER
    PASSWORD_CHANGED
    PASSWORD_RESET
    PASSWORD_RESET_LINK_SENT
    PLACED_ORDER
}

"An enumeration."
enum DiscountErrorCode {
    ALREADY_EXISTS
    CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum DiscountStatusEnum {
    ACTIVE
    EXPIRED
    SCHEDULED
}

enum DiscountValueTypeEnum {
    FIXED
    PERCENTAGE
}

"An enumeration."
enum DistanceUnitsEnum {
    CM
    FT
    INCH
    KM
    M
    YD
}

enum EventDeliveryAttemptSortField {
    "Sort event delivery attempts by created at."
    CREATED_AT
}

enum EventDeliverySortField {
    "Sort event deliveries by created at."
    CREATED_AT
}

enum EventDeliveryStatusEnum {
    FAILED
    PENDING
    SUCCESS
}

"An enumeration."
enum ExportErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
}

"An enumeration."
enum ExportEventsEnum {
    EXPORTED_FILE_SENT
    EXPORT_DELETED
    EXPORT_FAILED
    EXPORT_FAILED_INFO_SENT
    EXPORT_PENDING
    EXPORT_SUCCESS
}

enum ExportFileSortField {
    "Sort export file by created at."
    CREATED_AT
    "Sort export file by status."
    STATUS
    "Sort export file by updated at."
    UPDATED_AT
}

enum ExportScope {
    "Export all products."
    ALL
    "Export the filtered products."
    FILTER
    "Export products with given ids."
    IDS
}

"An enumeration."
enum ExternalNotificationErrorCodes {
    CHANNEL_INACTIVE
    INVALID_MODEL_TYPE
    NOT_FOUND
    REQUIRED
}

"An enumeration."
enum FileTypesEnum {
    CSV
    XLSX
}

"An enumeration."
enum FulfillmentStatus {
    CANCELED
    FULFILLED
    REFUNDED
    REFUNDED_AND_RETURNED
    REPLACED
    RETURNED
    WAITING_FOR_APPROVAL
}

"An enumeration."
enum GiftCardErrorCode {
    ALREADY_EXISTS
    DUPLICATED_INPUT_ITEM
    EXPIRED_GIFT_CARD
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum GiftCardEventsEnum {
    ACTIVATED
    BALANCE_RESET
    BOUGHT
    DEACTIVATED
    EXPIRY_DATE_UPDATED
    ISSUED
    NOTE_ADDED
    RESENT
    SENT_TO_CUSTOMER
    TAGS_UPDATED
    UPDATED
    USED_IN_ORDER
}

"An enumeration."
enum GiftCardSettingsErrorCode {
    GRAPHQL_ERROR
    INVALID
    REQUIRED
}

"An enumeration."
enum GiftCardSettingsExpiryTypeEnum {
    EXPIRY_PERIOD
    NEVER_EXPIRE
}

enum GiftCardSortField {
    "Sort orders by current balance."
    CURRENT_BALANCE
    "Sort orders by product."
    PRODUCT
    "Sort orders by used by."
    USED_BY
}

"An enumeration."
enum InvoiceErrorCode {
    EMAIL_NOT_SET
    INVALID_STATUS
    NOT_FOUND
    NOT_READY
    NO_INVOICE_PLUGIN
    NUMBER_NOT_SET
    REQUIRED
    URL_NOT_SET
}

"An enumeration."
enum JobStatusEnum {
    DELETED
    FAILED
    PENDING
    SUCCESS
}

"An enumeration."
enum LanguageCodeEnum {
    AF
    AF_NA
    AF_ZA
    AGQ
    AGQ_CM
    AK
    AK_GH
    AM
    AM_ET
    AR
    AR_AE
    AR_BH
    AR_DJ
    AR_DZ
    AR_EG
    AR_EH
    AR_ER
    AR_IL
    AR_IQ
    AR_JO
    AR_KM
    AR_KW
    AR_LB
    AR_LY
    AR_MA
    AR_MR
    AR_OM
    AR_PS
    AR_QA
    AR_SA
    AR_SD
    AR_SO
    AR_SS
    AR_SY
    AR_TD
    AR_TN
    AR_YE
    AS
    ASA
    ASA_TZ
    AST
    AST_ES
    AS_IN
    AZ
    AZ_CYRL
    AZ_CYRL_AZ
    AZ_LATN
    AZ_LATN_AZ
    BAS
    BAS_CM
    BE
    BEM
    BEM_ZM
    BEZ
    BEZ_TZ
    BE_BY
    BG
    BG_BG
    BM
    BM_ML
    BN
    BN_BD
    BN_IN
    BO
    BO_CN
    BO_IN
    BR
    BRX
    BRX_IN
    BR_FR
    BS
    BS_CYRL
    BS_CYRL_BA
    BS_LATN
    BS_LATN_BA
    CA
    CA_AD
    CA_ES
    CA_ES_VALENCIA
    CA_FR
    CA_IT
    CCP
    CCP_BD
    CCP_IN
    CE
    CEB
    CEB_PH
    CE_RU
    CGG
    CGG_UG
    CHR
    CHR_US
    CKB
    CKB_IQ
    CKB_IR
    CS
    CS_CZ
    CU
    CU_RU
    CY
    CY_GB
    DA
    DAV
    DAV_KE
    DA_DK
    DA_GL
    DE
    DE_AT
    DE_BE
    DE_CH
    DE_DE
    DE_IT
    DE_LI
    DE_LU
    DJE
    DJE_NE
    DSB
    DSB_DE
    DUA
    DUA_CM
    DYO
    DYO_SN
    DZ
    DZ_BT
    EBU
    EBU_KE
    EE
    EE_GH
    EE_TG
    EL
    EL_CY
    EL_GR
    EN
    EN_AE
    EN_AG
    EN_AI
    EN_AS
    EN_AT
    EN_AU
    EN_BB
    EN_BE
    EN_BI
    EN_BM
    EN_BS
    EN_BW
    EN_BZ
    EN_CA
    EN_CC
    EN_CH
    EN_CK
    EN_CM
    EN_CX
    EN_CY
    EN_DE
    EN_DG
    EN_DK
    EN_DM
    EN_ER
    EN_FI
    EN_FJ
    EN_FK
    EN_FM
    EN_GB
    EN_GD
    EN_GG
    EN_GH
    EN_GI
    EN_GM
    EN_GU
    EN_GY
    EN_HK
    EN_IE
    EN_IL
    EN_IM
    EN_IN
    EN_IO
    EN_JE
    EN_JM
    EN_KE
    EN_KI
    EN_KN
    EN_KY
    EN_LC
    EN_LR
    EN_LS
    EN_MG
    EN_MH
    EN_MO
    EN_MP
    EN_MS
    EN_MT
    EN_MU
    EN_MW
    EN_MY
    EN_NA
    EN_NF
    EN_NG
    EN_NL
    EN_NR
    EN_NU
    EN_NZ
    EN_PG
    EN_PH
    EN_PK
    EN_PN
    EN_PR
    EN_PW
    EN_RW
    EN_SB
    EN_SC
    EN_SD
    EN_SE
    EN_SG
    EN_SH
    EN_SI
    EN_SL
    EN_SS
    EN_SX
    EN_SZ
    EN_TC
    EN_TK
    EN_TO
    EN_TT
    EN_TV
    EN_TZ
    EN_UG
    EN_UM
    EN_US
    EN_VC
    EN_VG
    EN_VI
    EN_VU
    EN_WS
    EN_ZA
    EN_ZM
    EN_ZW
    EO
    ES
    ES_AR
    ES_BO
    ES_BR
    ES_BZ
    ES_CL
    ES_CO
    ES_CR
    ES_CU
    ES_DO
    ES_EA
    ES_EC
    ES_ES
    ES_GQ
    ES_GT
    ES_HN
    ES_IC
    ES_MX
    ES_NI
    ES_PA
    ES_PE
    ES_PH
    ES_PR
    ES_PY
    ES_SV
    ES_US
    ES_UY
    ES_VE
    ET
    ET_EE
    EU
    EU_ES
    EWO
    EWO_CM
    FA
    FA_AF
    FA_IR
    FF
    FF_ADLM
    FF_ADLM_BF
    FF_ADLM_CM
    FF_ADLM_GH
    FF_ADLM_GM
    FF_ADLM_GN
    FF_ADLM_GW
    FF_ADLM_LR
    FF_ADLM_MR
    FF_ADLM_NE
    FF_ADLM_NG
    FF_ADLM_SL
    FF_ADLM_SN
    FF_LATN
    FF_LATN_BF
    FF_LATN_CM
    FF_LATN_GH
    FF_LATN_GM
    FF_LATN_GN
    FF_LATN_GW
    FF_LATN_LR
    FF_LATN_MR
    FF_LATN_NE
    FF_LATN_NG
    FF_LATN_SL
    FF_LATN_SN
    FI
    FIL
    FIL_PH
    FI_FI
    FO
    FO_DK
    FO_FO
    FR
    FR_BE
    FR_BF
    FR_BI
    FR_BJ
    FR_BL
    FR_CA
    FR_CD
    FR_CF
    FR_CG
    FR_CH
    FR_CI
    FR_CM
    FR_DJ
    FR_DZ
    FR_FR
    FR_GA
    FR_GF
    FR_GN
    FR_GP
    FR_GQ
    FR_HT
    FR_KM
    FR_LU
    FR_MA
    FR_MC
    FR_MF
    FR_MG
    FR_ML
    FR_MQ
    FR_MR
    FR_MU
    FR_NC
    FR_NE
    FR_PF
    FR_PM
    FR_RE
    FR_RW
    FR_SC
    FR_SN
    FR_SY
    FR_TD
    FR_TG
    FR_TN
    FR_VU
    FR_WF
    FR_YT
    FUR
    FUR_IT
    FY
    FY_NL
    GA
    GA_GB
    GA_IE
    GD
    GD_GB
    GL
    GL_ES
    GSW
    GSW_CH
    GSW_FR
    GSW_LI
    GU
    GUZ
    GUZ_KE
    GU_IN
    GV
    GV_IM
    HA
    HAW
    HAW_US
    HA_GH
    HA_NE
    HA_NG
    HE
    HE_IL
    HI
    HI_IN
    HR
    HR_BA
    HR_HR
    HSB
    HSB_DE
    HU
    HU_HU
    HY
    HY_AM
    IA
    ID
    ID_ID
    IG
    IG_NG
    II
    II_CN
    IS
    IS_IS
    IT
    IT_CH
    IT_IT
    IT_SM
    IT_VA
    JA
    JA_JP
    JGO
    JGO_CM
    JMC
    JMC_TZ
    JV
    JV_ID
    KA
    KAB
    KAB_DZ
    KAM
    KAM_KE
    KA_GE
    KDE
    KDE_TZ
    KEA
    KEA_CV
    KHQ
    KHQ_ML
    KI
    KI_KE
    KK
    KKJ
    KKJ_CM
    KK_KZ
    KL
    KLN
    KLN_KE
    KL_GL
    KM
    KM_KH
    KN
    KN_IN
    KO
    KOK
    KOK_IN
    KO_KP
    KO_KR
    KS
    KSB
    KSB_TZ
    KSF
    KSF_CM
    KSH
    KSH_DE
    KS_ARAB
    KS_ARAB_IN
    KU
    KU_TR
    KW
    KW_GB
    KY
    KY_KG
    LAG
    LAG_TZ
    LB
    LB_LU
    LG
    LG_UG
    LKT
    LKT_US
    LN
    LN_AO
    LN_CD
    LN_CF
    LN_CG
    LO
    LO_LA
    LRC
    LRC_IQ
    LRC_IR
    LT
    LT_LT
    LU
    LUO
    LUO_KE
    LUY
    LUY_KE
    LU_CD
    LV
    LV_LV
    MAI
    MAI_IN
    MAS
    MAS_KE
    MAS_TZ
    MER
    MER_KE
    MFE
    MFE_MU
    MG
    MGH
    MGH_MZ
    MGO
    MGO_CM
    MG_MG
    MI
    MI_NZ
    MK
    MK_MK
    ML
    ML_IN
    MN
    MNI
    MNI_BENG
    MNI_BENG_IN
    MN_MN
    MR
    MR_IN
    MS
    MS_BN
    MS_ID
    MS_MY
    MS_SG
    MT
    MT_MT
    MUA
    MUA_CM
    MY
    MY_MM
    MZN
    MZN_IR
    NAQ
    NAQ_NA
    NB
    NB_NO
    NB_SJ
    ND
    NDS
    NDS_DE
    NDS_NL
    ND_ZW
    NE
    NE_IN
    NE_NP
    NL
    NL_AW
    NL_BE
    NL_BQ
    NL_CW
    NL_NL
    NL_SR
    NL_SX
    NMG
    NMG_CM
    NN
    NNH
    NNH_CM
    NN_NO
    NUS
    NUS_SS
    NYN
    NYN_UG
    OM
    OM_ET
    OM_KE
    OR
    OR_IN
    OS
    OS_GE
    OS_RU
    PA
    PA_ARAB
    PA_ARAB_PK
    PA_GURU
    PA_GURU_IN
    PCM
    PCM_NG
    PL
    PL_PL
    PRG
    PS
    PS_AF
    PS_PK
    PT
    PT_AO
    PT_BR
    PT_CH
    PT_CV
    PT_GQ
    PT_GW
    PT_LU
    PT_MO
    PT_MZ
    PT_PT
    PT_ST
    PT_TL
    QU
    QU_BO
    QU_EC
    QU_PE
    RM
    RM_CH
    RN
    RN_BI
    RO
    ROF
    ROF_TZ
    RO_MD
    RO_RO
    RU
    RU_BY
    RU_KG
    RU_KZ
    RU_MD
    RU_RU
    RU_UA
    RW
    RWK
    RWK_TZ
    RW_RW
    SAH
    SAH_RU
    SAQ
    SAQ_KE
    SAT
    SAT_OLCK
    SAT_OLCK_IN
    SBP
    SBP_TZ
    SD
    SD_ARAB
    SD_ARAB_PK
    SD_DEVA
    SD_DEVA_IN
    SE
    SEH
    SEH_MZ
    SES
    SES_ML
    SE_FI
    SE_NO
    SE_SE
    SG
    SG_CF
    SHI
    SHI_LATN
    SHI_LATN_MA
    SHI_TFNG
    SHI_TFNG_MA
    SI
    SI_LK
    SK
    SK_SK
    SL
    SL_SI
    SMN
    SMN_FI
    SN
    SN_ZW
    SO
    SO_DJ
    SO_ET
    SO_KE
    SO_SO
    SQ
    SQ_AL
    SQ_MK
    SQ_XK
    SR
    SR_CYRL
    SR_CYRL_BA
    SR_CYRL_ME
    SR_CYRL_RS
    SR_CYRL_XK
    SR_LATN
    SR_LATN_BA
    SR_LATN_ME
    SR_LATN_RS
    SR_LATN_XK
    SU
    SU_LATN
    SU_LATN_ID
    SV
    SV_AX
    SV_FI
    SV_SE
    SW
    SW_CD
    SW_KE
    SW_TZ
    SW_UG
    TA
    TA_IN
    TA_LK
    TA_MY
    TA_SG
    TE
    TEO
    TEO_KE
    TEO_UG
    TE_IN
    TG
    TG_TJ
    TH
    TH_TH
    TI
    TI_ER
    TI_ET
    TK
    TK_TM
    TO
    TO_TO
    TR
    TR_CY
    TR_TR
    TT
    TT_RU
    TWQ
    TWQ_NE
    TZM
    TZM_MA
    UG
    UG_CN
    UK
    UK_UA
    UR
    UR_IN
    UR_PK
    UZ
    UZ_ARAB
    UZ_ARAB_AF
    UZ_CYRL
    UZ_CYRL_UZ
    UZ_LATN
    UZ_LATN_UZ
    VAI
    VAI_LATN
    VAI_LATN_LR
    VAI_VAII
    VAI_VAII_LR
    VI
    VI_VN
    VO
    VUN
    VUN_TZ
    WAE
    WAE_CH
    WO
    WO_SN
    XH
    XH_ZA
    XOG
    XOG_UG
    YAV
    YAV_CM
    YI
    YO
    YO_BJ
    YO_NG
    YUE
    YUE_HANS
    YUE_HANS_CN
    YUE_HANT
    YUE_HANT_HK
    ZGH
    ZGH_MA
    ZH
    ZH_HANS
    ZH_HANS_CN
    ZH_HANS_HK
    ZH_HANS_MO
    ZH_HANS_SG
    ZH_HANT
    ZH_HANT_HK
    ZH_HANT_MO
    ZH_HANT_TW
    ZU
    ZU_ZA
}

"An enumeration."
enum MeasurementUnitsEnum {
    ACRE_FT
    ACRE_IN
    CM
    CUBIC_CENTIMETER
    CUBIC_DECIMETER
    CUBIC_FOOT
    CUBIC_INCH
    CUBIC_METER
    CUBIC_MILLIMETER
    CUBIC_YARD
    FL_OZ
    FT
    G
    INCH
    KG
    KM
    LB
    LITER
    M
    OZ
    PINT
    QT
    SQ_CM
    SQ_FT
    SQ_INCH
    SQ_KM
    SQ_M
    SQ_YD
    TONNE
    YD
}

"An enumeration."
enum MenuErrorCode {
    CANNOT_ASSIGN_NODE
    GRAPHQL_ERROR
    INVALID
    INVALID_MENU_ITEM
    NOT_FOUND
    NO_MENU_ITEM_PROVIDED
    REQUIRED
    TOO_MANY_MENU_ITEMS
    UNIQUE
}

enum MenuItemsSortField {
    "Sort menu items by name."
    NAME
}

enum MenuSortField {
    "Sort menus by items count."
    ITEMS_COUNT
    "Sort menus by name."
    NAME
}

"An enumeration."
enum MetadataErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
}

enum NavigationType {
    "Main storefront navigation."
    MAIN
    "Secondary storefront navigation."
    SECONDARY
}

enum OrderAction {
    "Represents the capture action."
    CAPTURE
    "Represents a mark-as-paid action."
    MARK_AS_PAID
    "Represents a refund action."
    REFUND
    "Represents a void action."
    VOID
}

enum OrderDirection {
    "Specifies an ascending sort order."
    ASC
    "Specifies a descending sort order."
    DESC
}

"An enumeration."
enum OrderDiscountType {
    MANUAL
    VOUCHER
}

"An enumeration."
enum OrderErrorCode {
    BILLING_ADDRESS_NOT_SET
    CANNOT_CANCEL_FULFILLMENT
    CANNOT_CANCEL_ORDER
    CANNOT_DELETE
    CANNOT_DISCOUNT
    CANNOT_FULFILL_UNPAID_ORDER
    CANNOT_REFUND
    CAPTURE_INACTIVE_PAYMENT
    CHANNEL_INACTIVE
    DUPLICATED_INPUT_ITEM
    FULFILL_ORDER_LINE
    GIFT_CARD_LINE
    GRAPHQL_ERROR
    INSUFFICIENT_STOCK
    INVALID
    INVALID_QUANTITY
    NOT_AVAILABLE_IN_CHANNEL
    NOT_EDITABLE
    NOT_FOUND
    ORDER_NO_SHIPPING_ADDRESS
    PAYMENT_ERROR
    PAYMENT_MISSING
    PRODUCT_NOT_PUBLISHED
    PRODUCT_UNAVAILABLE_FOR_PURCHASE
    REQUIRED
    SHIPPING_METHOD_NOT_APPLICABLE
    SHIPPING_METHOD_REQUIRED
    TAX_ERROR
    UNIQUE
    VOID_INACTIVE_PAYMENT
    ZERO_QUANTITY
}

"An enumeration."
enum OrderEventsEmailsEnum {
    CONFIRMED
    DIGITAL_LINKS
    FULFILLMENT_CONFIRMATION
    ORDER_CANCEL
    ORDER_CONFIRMATION
    ORDER_REFUND
    PAYMENT_CONFIRMATION
    SHIPPING_CONFIRMATION
    TRACKING_UPDATED
}

"An enumeration."
enum OrderEventsEnum {
    ADDED_PRODUCTS
    CANCELED
    CONFIRMED
    DRAFT_CREATED
    DRAFT_CREATED_FROM_REPLACE
    EMAIL_SENT
    EXTERNAL_SERVICE_NOTIFICATION
    FULFILLMENT_AWAITS_APPROVAL
    FULFILLMENT_CANCELED
    FULFILLMENT_FULFILLED_ITEMS
    FULFILLMENT_REFUNDED
    FULFILLMENT_REPLACED
    FULFILLMENT_RESTOCKED_ITEMS
    FULFILLMENT_RETURNED
    INVOICE_GENERATED
    INVOICE_REQUESTED
    INVOICE_SENT
    INVOICE_UPDATED
    NOTE_ADDED
    ORDER_DISCOUNT_ADDED
    ORDER_DISCOUNT_AUTOMATICALLY_UPDATED
    ORDER_DISCOUNT_DELETED
    ORDER_DISCOUNT_UPDATED
    ORDER_FULLY_PAID
    ORDER_LINE_DISCOUNT_REMOVED
    ORDER_LINE_DISCOUNT_UPDATED
    ORDER_LINE_PRODUCT_DELETED
    ORDER_LINE_VARIANT_DELETED
    ORDER_MARKED_AS_PAID
    ORDER_REPLACEMENT_CREATED
    OTHER
    OVERSOLD_ITEMS
    PAYMENT_AUTHORIZED
    PAYMENT_CAPTURED
    PAYMENT_FAILED
    PAYMENT_REFUNDED
    PAYMENT_VOIDED
    PLACED
    PLACED_FROM_DRAFT
    REMOVED_PRODUCTS
    TRACKING_UPDATED
    UPDATED_ADDRESS
}

"An enumeration."
enum OrderOriginEnum {
    CHECKOUT
    DRAFT
    REISSUE
}

"An enumeration."
enum OrderSettingsErrorCode {
    INVALID
}

enum OrderSortField {
    "Sort orders by creation date."
    CREATION_DATE
    "Sort orders by customer."
    CUSTOMER
    "Sort orders by fulfillment status."
    FULFILLMENT_STATUS
    "Sort orders by number."
    NUMBER
    "Sort orders by payment."
    PAYMENT
}

"An enumeration."
enum OrderStatus {
    CANCELED
    DRAFT
    FULFILLED
    PARTIALLY_FULFILLED
    PARTIALLY_RETURNED
    RETURNED
    UNCONFIRMED
    UNFULFILLED
}

enum OrderStatusFilter {
    CANCELED
    FULFILLED
    PARTIALLY_FULFILLED
    READY_TO_CAPTURE
    READY_TO_FULFILL
    UNCONFIRMED
    UNFULFILLED
}

"An enumeration."
enum PageErrorCode {
    ATTRIBUTE_ALREADY_ASSIGNED
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum PageSortField {
    "Sort pages by creation date."
    CREATION_DATE
    "Sort pages by publication date."
    PUBLICATION_DATE
    "Sort pages by slug."
    SLUG
    "Sort pages by title."
    TITLE
    "Sort pages by visibility."
    VISIBILITY
}

enum PageTypeSortField {
    "Sort page types by name."
    NAME
    "Sort page types by slug."
    SLUG
}

"An enumeration."
enum PaymentChargeStatusEnum {
    CANCELLED
    FULLY_CHARGED
    FULLY_REFUNDED
    NOT_CHARGED
    PARTIALLY_CHARGED
    PARTIALLY_REFUNDED
    PENDING
    REFUSED
}

"An enumeration."
enum PaymentErrorCode {
    BALANCE_CHECK_ERROR
    BILLING_ADDRESS_NOT_SET
    CHANNEL_INACTIVE
    CHECKOUT_EMAIL_NOT_SET
    GRAPHQL_ERROR
    INVALID
    INVALID_SHIPPING_METHOD
    NOT_FOUND
    NOT_SUPPORTED_GATEWAY
    NO_CHECKOUT_LINES
    PARTIAL_PAYMENT_NOT_ALLOWED
    PAYMENT_ERROR
    REQUIRED
    SHIPPING_ADDRESS_NOT_SET
    SHIPPING_METHOD_NOT_SET
    UNAVAILABLE_VARIANT_IN_CHANNEL
    UNIQUE
}

"An enumeration."
enum PermissionEnum {
    HANDLE_PAYMENTS
    IMPERSONATE_USER
    MANAGE_APPS
    MANAGE_CHANNELS
    MANAGE_CHECKOUTS
    MANAGE_DISCOUNTS
    MANAGE_GIFT_CARD
    MANAGE_MENUS
    MANAGE_ORDERS
    MANAGE_PAGES
    MANAGE_PAGE_TYPES_AND_ATTRIBUTES
    MANAGE_PLUGINS
    MANAGE_PRODUCTS
    MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES
    MANAGE_SETTINGS
    MANAGE_SHIPPING
    MANAGE_STAFF
    MANAGE_TRANSLATIONS
    MANAGE_USERS
}

"An enumeration."
enum PermissionGroupErrorCode {
    ASSIGN_NON_STAFF_MEMBER
    CANNOT_REMOVE_FROM_LAST_GROUP
    DUPLICATED_INPUT_ITEM
    LEFT_NOT_MANAGEABLE_PERMISSION
    OUT_OF_SCOPE_PERMISSION
    OUT_OF_SCOPE_USER
    REQUIRED
    UNIQUE
}

enum PermissionGroupSortField {
    "Sort permission group accounts by name."
    NAME
}

enum PluginConfigurationType {
    GLOBAL
    PER_CHANNEL
}

"An enumeration."
enum PluginErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    PLUGIN_MISCONFIGURED
    REQUIRED
    UNIQUE
}

enum PluginSortField {
    IS_ACTIVE
    NAME
}

"An enumeration."
enum PostalCodeRuleInclusionTypeEnum {
    EXCLUDE
    INCLUDE
}

enum ProductAttributeType {
    PRODUCT
    VARIANT
}

"An enumeration."
enum ProductErrorCode {
    ALREADY_EXISTS
    ATTRIBUTE_ALREADY_ASSIGNED
    ATTRIBUTE_CANNOT_BE_ASSIGNED
    ATTRIBUTE_VARIANTS_DISABLED
    CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    NOT_PRODUCTS_IMAGE
    NOT_PRODUCTS_VARIANT
    PREORDER_VARIANT_CANNOT_BE_DEACTIVATED
    PRODUCT_NOT_ASSIGNED_TO_CHANNEL
    PRODUCT_WITHOUT_CATEGORY
    REQUIRED
    UNIQUE
    UNSUPPORTED_MEDIA_PROVIDER
    VARIANT_NO_DIGITAL_CONTENT
}

enum ProductFieldEnum {
    CATEGORY
    CHARGE_TAXES
    COLLECTIONS
    DESCRIPTION
    NAME
    PRODUCT_MEDIA
    PRODUCT_TYPE
    PRODUCT_WEIGHT
    VARIANT_ID
    VARIANT_MEDIA
    VARIANT_SKU
    VARIANT_WEIGHT
}

"An enumeration."
enum ProductMediaType {
    IMAGE
    VIDEO
}

enum ProductOrderField {
    "Sort products by collection. Note: This option is available only for the `Collection.products` query."
    COLLECTION
    "Sort products by update date."
    DATE
    "Sort products by update date."
    LAST_MODIFIED
    "Sort products by a minimal price of a product's variant."
    MINIMAL_PRICE
    "Sort products by name."
    NAME
    "Sort products by price."
    PRICE
    "Sort products by publication date."
    PUBLICATION_DATE
    "Sort products by publication status."
    PUBLISHED
    "Sort products by name."
    RANK
    "Sort products by rating."
    RATING
    "Sort products by type."
    TYPE
}

enum ProductTypeConfigurable {
    CONFIGURABLE
    SIMPLE
}

enum ProductTypeEnum {
    DIGITAL
    SHIPPABLE
}

"An enumeration."
enum ProductTypeKindEnum {
    GIFT_CARD
    NORMAL
}

enum ProductTypeSortField {
    "Sort products by type."
    DIGITAL
    "Sort products by name."
    NAME
    "Sort products by shipping."
    SHIPPING_REQUIRED
}

enum ReportingPeriod {
    THIS_MONTH
    TODAY
}

enum SaleSortField {
    "Sort sales by end date."
    END_DATE
    "Sort sales by name."
    NAME
    "Sort sales by start date."
    START_DATE
    "Sort sales by type."
    TYPE
    "Sort sales by value."
    VALUE
}

enum SaleType {
    FIXED
    PERCENTAGE
}

"An enumeration."
enum ShippingErrorCode {
    ALREADY_EXISTS
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    MAX_LESS_THAN_MIN
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum ShippingMethodTypeEnum {
    PRICE
    WEIGHT
}

"An enumeration."
enum ShopErrorCode {
    ALREADY_EXISTS
    CANNOT_FETCH_TAX_RATES
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum StaffMemberStatus {
    "User account has been activated."
    ACTIVE
    "User account has not been activated yet."
    DEACTIVATED
}

enum StockAvailability {
    IN_STOCK
    OUT_OF_STOCK
}

"An enumeration."
enum StockErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"Enum representing the type of a payment storage in a gateway."
enum StorePaymentMethodEnum {
    "Storage is disabled. The payment is not stored."
    NONE
    "Off session storage type. The payment is stored to be reused even if the customer is absent."
    OFF_SESSION
    "On session storage type. The payment is stored only to be reused when the customer is present in the checkout flow."
    ON_SESSION
}

"An enumeration."
enum TimePeriodTypeEnum {
    DAY
    MONTH
    WEEK
    YEAR
}

"An enumeration."
enum TransactionKind {
    ACTION_TO_CONFIRM
    AUTH
    CANCEL
    CAPTURE
    CONFIRM
    EXTERNAL
    PENDING
    REFUND
    REFUND_ONGOING
    VOID
}

enum TranslatableKinds {
    ATTRIBUTE
    ATTRIBUTE_VALUE
    CATEGORY
    COLLECTION
    MENU_ITEM
    PAGE
    PRODUCT
    SALE
    SHIPPING_METHOD
    VARIANT
    VOUCHER
}

"An enumeration."
enum TranslationErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
}

"An enumeration."
enum UploadErrorCode {
    GRAPHQL_ERROR
}

enum UserSortField {
    "Sort users by email."
    EMAIL
    "Sort users by first name."
    FIRST_NAME
    "Sort users by last name."
    LAST_NAME
    "Sort users by order count."
    ORDER_COUNT
}

enum VariantAttributeScope {
    ALL
    NOT_VARIANT_SELECTION
    VARIANT_SELECTION
}

"An enumeration."
enum VolumeUnitsEnum {
    ACRE_FT
    ACRE_IN
    CUBIC_CENTIMETER
    CUBIC_DECIMETER
    CUBIC_FOOT
    CUBIC_INCH
    CUBIC_METER
    CUBIC_MILLIMETER
    CUBIC_YARD
    FL_OZ
    LITER
    PINT
    QT
}

enum VoucherDiscountType {
    FIXED
    PERCENTAGE
    SHIPPING
}

enum VoucherSortField {
    "Sort vouchers by code."
    CODE
    "Sort vouchers by end date."
    END_DATE
    "Sort vouchers by minimum spent amount."
    MINIMUM_SPENT_AMOUNT
    "Sort vouchers by start date."
    START_DATE
    "Sort vouchers by type."
    TYPE
    "Sort vouchers by usage limit."
    USAGE_LIMIT
    "Sort vouchers by value."
    VALUE
}

enum VoucherTypeEnum {
    ENTIRE_ORDER
    SHIPPING
    SPECIFIC_PRODUCT
}

"An enumeration."
enum WarehouseClickAndCollectOptionEnum {
    ALL
    DISABLED
    LOCAL
}

"An enumeration."
enum WarehouseErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum WarehouseSortField {
    "Sort warehouses by name."
    NAME
}

"An enumeration."
enum WebhookErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"Enum determining type of webhook."
enum WebhookEventTypeAsyncEnum {
    "All the events."
    ANY_EVENTS
    "A new checkout is created."
    CHECKOUT_CREATED
    "A checkout is updated. It also triggers all updates related to the checkout."
    CHECKOUT_UPDATED
    "A new collection is created."
    COLLECTION_CREATED
    "A collection is deleted."
    COLLECTION_DELETED
    "A collection is updated."
    COLLECTION_UPDATED
    "A new customer account is created."
    CUSTOMER_CREATED
    "A customer account is updated."
    CUSTOMER_UPDATED
    DRAFT_ORDER_CREATED
    DRAFT_ORDER_DELETED
    DRAFT_ORDER_UPDATED
    "A fulfillment is cancelled."
    FULFILLMENT_CANCELED
    "A new fulfillment is created."
    FULFILLMENT_CREATED
    "An invoice is deleted."
    INVOICE_DELETED
    "An invoice for order requested."
    INVOICE_REQUESTED
    "Invoice has been sent."
    INVOICE_SENT
    "User notification triggered."
    NOTIFY_USER
    "An order is cancelled."
    ORDER_CANCELLED
    "An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled."
    ORDER_CONFIRMED
    "A new order is placed."
    ORDER_CREATED
    "An order is fulfilled."
    ORDER_FULFILLED
    "Payment is made and an order is fully paid."
    ORDER_FULLY_PAID
    "An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED."
    ORDER_UPDATED
    "A new page is created."
    PAGE_CREATED
    "A page is deleted."
    PAGE_DELETED
    "A page is updated."
    PAGE_UPDATED
    "A new product is created."
    PRODUCT_CREATED
    "A product is deleted."
    PRODUCT_DELETED
    "A product is updated."
    PRODUCT_UPDATED
    PRODUCT_VARIANT_BACK_IN_STOCK
    "A new product variant is created."
    PRODUCT_VARIANT_CREATED
    "A product variant is deleted."
    PRODUCT_VARIANT_DELETED
    PRODUCT_VARIANT_OUT_OF_STOCK
    "A product variant is updated."
    PRODUCT_VARIANT_UPDATED
    SALE_CREATED
    SALE_DELETED
    SALE_UPDATED
    TRANSLATION_CREATED
    TRANSLATION_UPDATED
}

"Enum determining type of webhook."
enum WebhookEventTypeEnum {
    ANY_EVENTS
    CHECKOUT_CREATED
    CHECKOUT_FILTER_SHIPPING_METHODS
    CHECKOUT_UPDATED
    COLLECTION_CREATED
    COLLECTION_DELETED
    COLLECTION_UPDATED
    CUSTOMER_CREATED
    CUSTOMER_UPDATED
    DRAFT_ORDER_CREATED
    DRAFT_ORDER_DELETED
    DRAFT_ORDER_UPDATED
    FULFILLMENT_CANCELED
    FULFILLMENT_CREATED
    INVOICE_DELETED
    INVOICE_REQUESTED
    INVOICE_SENT
    NOTIFY_USER
    ORDER_CANCELLED
    ORDER_CONFIRMED
    ORDER_CREATED
    ORDER_FILTER_SHIPPING_METHODS
    ORDER_FULFILLED
    ORDER_FULLY_PAID
    ORDER_UPDATED
    PAGE_CREATED
    PAGE_DELETED
    PAGE_UPDATED
    PAYMENT_AUTHORIZE
    PAYMENT_CAPTURE
    PAYMENT_CONFIRM
    PAYMENT_LIST_GATEWAYS
    PAYMENT_PROCESS
    PAYMENT_REFUND
    PAYMENT_VOID
    PRODUCT_CREATED
    PRODUCT_DELETED
    PRODUCT_UPDATED
    PRODUCT_VARIANT_BACK_IN_STOCK
    PRODUCT_VARIANT_CREATED
    PRODUCT_VARIANT_DELETED
    PRODUCT_VARIANT_OUT_OF_STOCK
    PRODUCT_VARIANT_UPDATED
    SALE_CREATED
    SALE_DELETED
    SALE_UPDATED
    SHIPPING_LIST_METHODS_FOR_CHECKOUT
    TRANSLATION_CREATED
    TRANSLATION_UPDATED
}

"Enum determining type of webhook."
enum WebhookEventTypeSyncEnum {
    CHECKOUT_FILTER_SHIPPING_METHODS
    ORDER_FILTER_SHIPPING_METHODS
    PAYMENT_AUTHORIZE
    PAYMENT_CAPTURE
    PAYMENT_CONFIRM
    PAYMENT_LIST_GATEWAYS
    PAYMENT_PROCESS
    PAYMENT_REFUND
    PAYMENT_VOID
    SHIPPING_LIST_METHODS_FOR_CHECKOUT
}

"An enumeration."
enum WebhookSampleEventTypeEnum {
    CHECKOUT_CREATED
    CHECKOUT_UPDATED
    COLLECTION_CREATED
    COLLECTION_DELETED
    COLLECTION_UPDATED
    CUSTOMER_CREATED
    CUSTOMER_UPDATED
    DRAFT_ORDER_CREATED
    DRAFT_ORDER_DELETED
    DRAFT_ORDER_UPDATED
    FULFILLMENT_CANCELED
    FULFILLMENT_CREATED
    INVOICE_DELETED
    INVOICE_REQUESTED
    INVOICE_SENT
    NOTIFY_USER
    ORDER_CANCELLED
    ORDER_CONFIRMED
    ORDER_CREATED
    ORDER_FULFILLED
    ORDER_FULLY_PAID
    ORDER_UPDATED
    PAGE_CREATED
    PAGE_DELETED
    PAGE_UPDATED
    PRODUCT_CREATED
    PRODUCT_DELETED
    PRODUCT_UPDATED
    PRODUCT_VARIANT_BACK_IN_STOCK
    PRODUCT_VARIANT_CREATED
    PRODUCT_VARIANT_DELETED
    PRODUCT_VARIANT_OUT_OF_STOCK
    PRODUCT_VARIANT_UPDATED
    SALE_CREATED
    SALE_DELETED
    SALE_UPDATED
    TRANSLATION_CREATED
    TRANSLATION_UPDATED
}

"An enumeration."
enum WeightUnitsEnum {
    G
    KG
    LB
    OZ
    TONNE
}

"""

The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""

The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""

The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""

Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""

Positive Decimal scalar implementation.

Should be used in places where value must be positive.
"""
scalar PositiveDecimal

scalar UUID

"Variables of this type must be set to null in mutations. They will be replaced with a filename from a following multipart part containing a binary file. See: https://github.com/jaydenseric/graphql-multipart-request-spec."
scalar Upload

scalar WeightScalar

"_Any value scalar as defined by Federation spec."
scalar _Any

input AccountInput {
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "Given name."
    firstName: String
    "User language code."
    languageCode: LanguageCodeEnum
    "Family name."
    lastName: String
}

input AccountRegisterInput {
    "Slug of a channel which will be used to notify users. Optional when only one channel exists."
    channel: String
    "The email address of the user."
    email: String!
    "Given name."
    firstName: String
    "User language code."
    languageCode: LanguageCodeEnum
    "Family name."
    lastName: String
    "User public metadata."
    metadata: [MetadataInput!]
    "Password."
    password: String!
    "Base of frontend URL that will be needed to create confirmation URL."
    redirectUrl: String
}

input AddressInput {
    "City."
    city: String
    "District."
    cityArea: String
    "Company or organization."
    companyName: String
    "Country."
    country: CountryCode
    "State or province."
    countryArea: String
    "Given name."
    firstName: String
    "Family name."
    lastName: String
    "Phone number."
    phone: String
    "Postal code."
    postalCode: String
    "Address."
    streetAddress1: String
    "Address."
    streetAddress2: String
}

input AppExtensionFilterInput {
    mount: [AppExtensionMountEnum]
    target: AppExtensionTargetEnum
}

input AppFilterInput {
    isActive: Boolean
    search: String
    type: AppTypeEnum
}

input AppInput {
    "Name of the app."
    name: String
    "List of permission code names to assign to this app."
    permissions: [PermissionEnum]
}

input AppInstallInput {
    "Determine if app will be set active or not."
    activateAfterInstallation: Boolean
    "Name of the app to install."
    appName: String
    "Url to app's manifest in JSON format."
    manifestUrl: String
    "List of permission code names to assign to this app."
    permissions: [PermissionEnum]
}

input AppSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort apps by the selected field."
    field: AppSortField!
}

input AppTokenInput {
    "ID of app."
    app: ID!
    "Name of the token."
    name: String
}

input AttributeChoicesSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort attribute choices by the selected field."
    field: AttributeChoicesSortField!
}

input AttributeCreateInput {
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean
    "The entity type which can be used as a reference."
    entityType: AttributeEntityTypeEnum
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "Whether the attribute is for variants only."
    isVariantOnly: Boolean
    "Name of an attribute displayed in the interface."
    name: String!
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int
    "The attribute type."
    type: AttributeTypeEnum!
    "The unit of attribute values."
    unit: MeasurementUnitsEnum
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean
    "List of attribute's values."
    values: [AttributeValueCreateInput]
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean
}

input AttributeFilterInput {
    availableInGrid: Boolean
    """

    Specifies the channel by which the data should be filtered.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    filterableInDashboard: Boolean
    filterableInStorefront: Boolean
    ids: [ID]
    inCategory: ID
    inCollection: ID
    isVariantOnly: Boolean
    metadata: [MetadataFilter]
    search: String
    type: AttributeTypeEnum
    valueRequired: Boolean
    visibleInStorefront: Boolean
}

input AttributeInput {
    "The boolean value of the attribute."
    boolean: Boolean
    "The date range that the returned values should be in."
    date: DateRangeInput
    "The date time range that the returned values should be in."
    dateTime: DateTimeRangeInput
    "Internal representation of an attribute name."
    slug: String!
    "Internal representation of a value (unique per attribute)."
    values: [String]
    "The range that the returned values should be in."
    valuesRange: IntRangeInput
}

input AttributeSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort attributes by the selected field."
    field: AttributeSortField!
}

input AttributeUpdateInput {
    "New values to be created for this attribute."
    addValues: [AttributeValueUpdateInput]
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean
    "Whether the attribute is for variants only."
    isVariantOnly: Boolean
    "Name of an attribute displayed in the interface."
    name: String
    "IDs of values to be removed from this attribute."
    removeValues: [ID]
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int
    "The unit of attribute values."
    unit: MeasurementUnitsEnum
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean
}

input AttributeValueCreateInput {
    "File content type."
    contentType: String
    "URL of the file attribute. Every time, a new value is created."
    fileUrl: String
    "Name of a value displayed in the interface."
    name: String!
    "Represents the text (JSON) of the attribute value."
    richText: JSONString
    "Represent value of the attribute value (e.g. color values for swatch attributes)."
    value: String
}

input AttributeValueFilterInput {
    search: String
}

input AttributeValueInput {
    "Represents the boolean value of the attribute value."
    boolean: Boolean
    "File content type."
    contentType: String
    "Represents the date value of the attribute value."
    date: Date
    "Represents the date time value of the attribute value."
    dateTime: DateTime
    "URL of the file attribute. Every time, a new value is created."
    file: String
    "ID of the selected attribute."
    id: ID
    "List of entity IDs that will be used as references."
    references: [ID!]
    "Text content in JSON format."
    richText: JSONString
    "The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created."
    values: [String!]
}

input AttributeValueTranslationInput {
    name: String
    richText: JSONString
}

input AttributeValueUpdateInput {
    "File content type."
    contentType: String
    "URL of the file attribute. Every time, a new value is created."
    fileUrl: String
    "Name of a value displayed in the interface."
    name: String
    "Represents the text (JSON) of the attribute value."
    richText: JSONString
    "Represent value of the attribute value (e.g. color values for swatch attributes)."
    value: String
}

input BulkAttributeValueInput {
    "The boolean value of an attribute to resolve. If the passed value is non-existent, it will be created."
    boolean: Boolean
    "ID of the selected attribute."
    id: ID
    "The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created."
    values: [String!]
}

input CardInput {
    "Payment method nonce, a token returned by the appropriate provider's SDK."
    code: String!
    "Card security code."
    cvc: String
    "Information about currency and amount."
    money: MoneyInput!
}

input CatalogueInput {
    "Categories related to the discount."
    categories: [ID]
    "Collections related to the discount."
    collections: [ID]
    "Products related to the discount."
    products: [ID]
    "New in Saleor 3.1. Product variant related to the discount."
    variants: [ID]
}

input CategoryFilterInput {
    ids: [ID]
    metadata: [MetadataFilter]
    search: String
}

input CategoryInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for a product media."
    backgroundImageAlt: String
    "Category description (JSON)."
    description: JSONString
    "Category name."
    name: String
    "Search engine optimization fields."
    seo: SeoInput
    "Category slug."
    slug: String
}

input CategorySortingInput {
    """

    Specifies the channel in which to sort the data.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort categories by the selected field."
    field: CategorySortField!
}

input ChannelCreateInput {
    "List of shipping zones to assign to the channel."
    addShippingZones: [ID!]
    "Currency of the channel."
    currencyCode: String!
    "New in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided."
    defaultCountry: CountryCode!
    "isActive flag."
    isActive: Boolean
    "Name of the channel."
    name: String!
    "Slug of the channel."
    slug: String!
}

input ChannelDeleteInput {
    "ID of channel to migrate orders from origin channel."
    channelId: ID!
}

input ChannelUpdateInput {
    "List of shipping zones to assign to the channel."
    addShippingZones: [ID!]
    "New in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided."
    defaultCountry: CountryCode
    "isActive flag."
    isActive: Boolean
    "Name of the channel."
    name: String
    "List of shipping zones to unassign from the channel."
    removeShippingZones: [ID!]
    "Slug of the channel."
    slug: String
}

input CheckoutCreateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "Slug of a channel in which to create a checkout."
    channel: String
    "The customer's email address."
    email: String
    "Checkout language code."
    languageCode: LanguageCodeEnum
    "A list of checkout lines, each containing information about an item in the checkout."
    lines: [CheckoutLineInput]!
    "The mailing address to where the checkout will be shipped. Note: the address will be ignored if the checkout doesn't contain shippable items."
    shippingAddress: AddressInput
}

input CheckoutFilterInput {
    channels: [ID]
    created: DateRangeInput
    customer: String
    metadata: [MetadataFilter]
    search: String
}

input CheckoutLineInput {
    "The number of items purchased."
    quantity: Int!
    "ID of the product variant."
    variantId: ID!
}

input CheckoutSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort checkouts by the selected field."
    field: CheckoutSortField!
}

input CollectionChannelListingUpdateInput {
    "List of channels to which the collection should be assigned."
    addChannels: [PublishableChannelListingInput!]
    "List of channels from which the collection should be unassigned."
    removeChannels: [ID!]
}

input CollectionCreateInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for an image."
    backgroundImageAlt: String
    "Description of the collection (JSON)."
    description: JSONString
    "Informs whether a collection is published."
    isPublished: Boolean
    "Name of the collection."
    name: String
    "List of products to be added to the collection."
    products: [ID]
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Slug of the collection."
    slug: String
}

input CollectionFilterInput {
    """

    Specifies the channel by which the data should be filtered.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    ids: [ID]
    metadata: [MetadataFilter]
    published: CollectionPublished
    search: String
}

input CollectionInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for an image."
    backgroundImageAlt: String
    "Description of the collection (JSON)."
    description: JSONString
    "Informs whether a collection is published."
    isPublished: Boolean
    "Name of the collection."
    name: String
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Slug of the collection."
    slug: String
}

input CollectionSortingInput {
    """

    Specifies the channel in which to sort the data.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort collections by the selected field."
    field: CollectionSortField!
}

input ConfigurationItemInput {
    "Name of the field to update."
    name: String!
    "Value of the given field to update."
    value: String
}

input CountryFilterInput {
    "Boolean for filtering countries by having shipping zone assigned.If 'true', return countries with shipping zone assigned.If 'false', return countries without any shipping zone assigned.If the argument is not provided (null), return all countries."
    attachedToShippingZones: Boolean
}

input CustomerFilterInput {
    dateJoined: DateRangeInput
    metadata: [MetadataFilter]
    numberOfOrders: IntRangeInput
    placedOrders: DateRangeInput
    search: String
    updatedAt: DateTimeRangeInput
}

input CustomerInput {
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "User language code."
    languageCode: LanguageCodeEnum
    "Family name."
    lastName: String
    "A note about the user."
    note: String
}

input DateRangeInput {
    "Start date."
    gte: Date
    "End date."
    lte: Date
}

input DateTimeRangeInput {
    "Start date."
    gte: DateTime
    "End date."
    lte: DateTime
}

input DigitalContentInput {
    "Overwrite default automatic_fulfillment setting for variant."
    automaticFulfillment: Boolean
    "Determines how many times a download link can be accessed by a customer."
    maxDownloads: Int
    "Determines for how many days a download link is active since it was generated."
    urlValidDays: Int
    "Use default digital content settings for this product."
    useDefaultSettings: Boolean!
}

input DigitalContentUploadInput {
    "Overwrite default automatic_fulfillment setting for variant."
    automaticFulfillment: Boolean
    "Represents an file in a multipart request."
    contentFile: Upload!
    "Determines how many times a download link can be accessed by a customer."
    maxDownloads: Int
    "Determines for how many days a download link is active since it was generated."
    urlValidDays: Int
    "Use default digital content settings for this product."
    useDefaultSettings: Boolean!
}

input DigitalContentUrlCreateInput {
    "Digital content ID which URL will belong to."
    content: ID!
}

input DraftOrderCreateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "ID of the channel associated with the order."
    channelId: ID
    "A note from a customer. Visible by customers in the order summary."
    customerNote: String
    "Discount amount for the order."
    discount: PositiveDecimal
    "Variant line input consisting of variant ID and quantity of products."
    lines: [OrderLineCreateInput]
    "URL of a view where users should be redirected to see the order details. URL in RFC 1808 format."
    redirectUrl: String
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "ID of a selected shipping method."
    shippingMethod: ID
    "Customer associated with the draft order."
    user: ID
    "Email address of the customer."
    userEmail: String
    "ID of the voucher associated with the order."
    voucher: ID
}

input DraftOrderInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "ID of the channel associated with the order."
    channelId: ID
    "A note from a customer. Visible by customers in the order summary."
    customerNote: String
    "Discount amount for the order."
    discount: PositiveDecimal
    "URL of a view where users should be redirected to see the order details. URL in RFC 1808 format."
    redirectUrl: String
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "ID of a selected shipping method."
    shippingMethod: ID
    "Customer associated with the draft order."
    user: ID
    "Email address of the customer."
    userEmail: String
    "ID of the voucher associated with the order."
    voucher: ID
}

input EventDeliveryAttemptSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort attempts by the selected field."
    field: EventDeliveryAttemptSortField!
}

input EventDeliveryFilterInput {
    eventType: WebhookEventTypeEnum
    status: EventDeliveryStatusEnum
}

input EventDeliverySortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort deliveries by the selected field."
    field: EventDeliverySortField!
}

input ExportFileFilterInput {
    app: String
    createdAt: DateTimeRangeInput
    status: JobStatusEnum
    updatedAt: DateTimeRangeInput
    user: String
}

input ExportFileSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort export file by the selected field."
    field: ExportFileSortField!
}

input ExportGiftCardsInput {
    "Type of exported file."
    fileType: FileTypesEnum!
    "Filtering options for gift cards."
    filter: GiftCardFilterInput
    "List of gift cards IDs to export."
    ids: [ID!]
    "Determine which gift cards should be exported."
    scope: ExportScope!
}

input ExportInfoInput {
    "List of attribute ids witch should be exported."
    attributes: [ID!]
    "List of channels ids which should be exported."
    channels: [ID!]
    "List of product fields witch should be exported."
    fields: [ProductFieldEnum!]
    "List of warehouse ids witch should be exported."
    warehouses: [ID!]
}

input ExportProductsInput {
    "Input with info about fields which should be exported."
    exportInfo: ExportInfoInput
    "Type of exported file."
    fileType: FileTypesEnum!
    "Filtering options for products."
    filter: ProductFilterInput
    "List of products IDs to export."
    ids: [ID!]
    "Determine which products should be exported."
    scope: ExportScope!
}

input ExternalNotificationTriggerInput {
    "External event type. This field is passed to a plugin as an event type."
    externalEventType: String!
    "Additional payload that will be merged with the one based on the bussines object ID."
    extraPayload: JSONString
    "The list of customers or orders node IDs that will be serialized and included in the notification payload."
    ids: [ID]!
}

input FulfillmentCancelInput {
    "ID of a warehouse where items will be restocked. Optional when fulfillment is in WAITING_FOR_APPROVAL state."
    warehouseId: ID
}

input FulfillmentUpdateTrackingInput {
    "If true, send an email notification to the customer."
    notifyCustomer: Boolean
    "Fulfillment tracking number."
    trackingNumber: String
}

input GiftCardAddNoteInput {
    "Note message."
    message: String!
}

input GiftCardBulkCreateInput {
    "Balance of the gift card."
    balance: PriceInput!
    "The number of cards to issue."
    count: Int!
    "The gift card expiry date."
    expiryDate: Date
    "Determine if gift card is active."
    isActive: Boolean!
    "The gift card tags."
    tags: [String!]
}

input GiftCardCreateInput {
    "New in Saleor 3.1. The gift card tags to add. Note: this feature is in a preview state and can be subject to changes at later point."
    addTags: [String!]
    "Balance of the gift card."
    balance: PriceInput!
    "New in Saleor 3.1. Slug of a channel from which the email should be sent. Note: this feature is in a preview state and can be subject to changes at later point."
    channel: String
    """

    Code to use the gift card.

    DEPRECATED: this field will be removed in Saleor 4.0. The code is now auto generated.
    """
    code: String
    """

    End date of the gift card in ISO 8601 format.

    DEPRECATED: this field will be removed in Saleor 4.0. Use `expiryDate` from `expirySettings` instead.
    """
    endDate: Date
    "New in Saleor 3.1. The gift card expiry date. Note: this feature is in a preview state and can be subject to changes at later point."
    expiryDate: Date
    "New in Saleor 3.1. Determine if gift card is active. Note: this feature is in a preview state and can be subject to changes at later point."
    isActive: Boolean!
    "New in Saleor 3.1. The gift card note from the staff member. Note: this feature is in a preview state and can be subject to changes at later point."
    note: String
    """

    Start date of the gift card in ISO 8601 format.

    DEPRECATED: this field will be removed in Saleor 4.0.
    """
    startDate: Date
    "Email of the customer to whom gift card will be sent."
    userEmail: String
}

input GiftCardEventFilterInput {
    orders: [ID!]
    type: GiftCardEventsEnum
}

input GiftCardFilterInput {
    code: String
    currency: String
    currentBalance: PriceRangeInput
    initialBalance: PriceRangeInput
    isActive: Boolean
    metadata: [MetadataFilter]
    products: [ID]
    tags: [String]
    used: Boolean
    usedBy: [ID]
}

input GiftCardResendInput {
    "Slug of a channel from which the email should be sent."
    channel: String!
    "Email to which gift card should be send."
    email: String
    "ID of a gift card to resend."
    id: ID!
}

input GiftCardSettingsUpdateInput {
    "Defines gift card expiry period."
    expiryPeriod: TimePeriodInputType
    "Defines gift card default expiry settings."
    expiryType: GiftCardSettingsExpiryTypeEnum
}

input GiftCardSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort gift cards by the selected field."
    field: GiftCardSortField!
}

input GiftCardTagFilterInput {
    search: String
}

input GiftCardUpdateInput {
    "New in Saleor 3.1. The gift card tags to add. Note: this feature is in a preview state and can be subject to changes at later point."
    addTags: [String!]
    "New in Saleor 3.1. The gift card balance amount. Note: this feature is in a preview state and can be subject to changes at later point."
    balanceAmount: PositiveDecimal
    """

    End date of the gift card in ISO 8601 format.

    DEPRECATED: this field will be removed in Saleor 4.0. Use `expiryDate` from `expirySettings` instead.
    """
    endDate: Date
    "New in Saleor 3.1. The gift card expiry date. Note: this feature is in a preview state and can be subject to changes at later point."
    expiryDate: Date
    "New in Saleor 3.1. The gift card tags to remove. Note: this feature is in a preview state and can be subject to changes at later point."
    removeTags: [String!]
    """

    Start date of the gift card in ISO 8601 format.

    DEPRECATED: this field will be removed in Saleor 4.0.
    """
    startDate: Date
}

input IntRangeInput {
    "Value greater than or equal to."
    gte: Int
    "Value less than or equal to."
    lte: Int
}

input InvoiceCreateInput {
    "Invoice number."
    number: String!
    "URL of an invoice to download."
    url: String!
}

input MenuCreateInput {
    "List of menu items."
    items: [MenuItemInput]
    "Name of the menu."
    name: String!
    "Slug of the menu. Will be generated if not provided."
    slug: String
}

input MenuFilterInput {
    metadata: [MetadataFilter]
    search: String
    slug: [String]
}

input MenuInput {
    "Name of the menu."
    name: String
    "Slug of the menu."
    slug: String
}

input MenuItemCreateInput {
    "Category to which item points."
    category: ID
    "Collection to which item points."
    collection: ID
    "Menu to which item belongs."
    menu: ID!
    "Name of the menu item."
    name: String!
    "Page to which item points."
    page: ID
    "ID of the parent menu. If empty, menu will be top level menu."
    parent: ID
    "URL of the pointed item."
    url: String
}

input MenuItemFilterInput {
    metadata: [MetadataFilter]
    search: String
}

input MenuItemInput {
    "Category to which item points."
    category: ID
    "Collection to which item points."
    collection: ID
    "Name of the menu item."
    name: String
    "Page to which item points."
    page: ID
    "URL of the pointed item."
    url: String
}

input MenuItemMoveInput {
    "The menu item ID to move."
    itemId: ID!
    "ID of the parent menu. If empty, menu will be top level menu."
    parentId: ID
    "The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input MenuItemSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort menu items by the selected field."
    field: MenuItemsSortField!
}

input MenuSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort menus by the selected field."
    field: MenuSortField!
}

input MetadataFilter {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String
}

input MetadataInput {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

input MoneyInput {
    "Amount of money."
    amount: PositiveDecimal!
    "Currency code."
    currency: String!
}

input MoveProductInput {
    "The ID of the product to move."
    productId: ID!
    "The relative sorting position of the product (from -inf to +inf) starting from the first given product's actual position.1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input NameTranslationInput {
    name: String
}

input OrderAddNoteInput {
    "Note message."
    message: String!
}

input OrderDiscountCommonInput {
    "Explanation for the applied discount."
    reason: String
    "Value of the discount. Can store fixed value or percent value"
    value: PositiveDecimal!
    "Type of the discount: fixed or percent"
    valueType: DiscountValueTypeEnum!
}

input OrderDraftFilterInput {
    channels: [ID]
    created: DateRangeInput
    customer: String
    metadata: [MetadataFilter]
    search: String
}

input OrderFilterInput {
    channels: [ID]
    created: DateRangeInput
    customer: String
    giftCardBought: Boolean
    giftCardUsed: Boolean
    ids: [ID]
    isClickAndCollect: Boolean
    isPreorder: Boolean
    metadata: [MetadataFilter]
    paymentStatus: [PaymentChargeStatusEnum]
    search: String
    status: [OrderStatusFilter]
    updatedAt: DateTimeRangeInput
}

input OrderFulfillInput {
    "If true, then allow proceed fulfillment when stock is exceeded."
    allowStockToBeExceeded: Boolean
    "List of items informing how to fulfill the order."
    lines: [OrderFulfillLineInput!]!
    "If true, send an email notification to the customer."
    notifyCustomer: Boolean
}

input OrderFulfillLineInput {
    "The ID of the order line."
    orderLineId: ID
    "List of stock items to create."
    stocks: [OrderFulfillStockInput!]!
}

input OrderFulfillStockInput {
    "The number of line items to be fulfilled from given warehouse."
    quantity: Int!
    "ID of the warehouse from which the item will be fulfilled."
    warehouse: ID!
}

input OrderLineCreateInput {
    "Number of variant items ordered."
    quantity: Int!
    "Product variant ID."
    variantId: ID!
}

input OrderLineInput {
    "Number of variant items ordered."
    quantity: Int!
}

input OrderRefundFulfillmentLineInput {
    "The ID of the fulfillment line to refund."
    fulfillmentLineId: ID!
    "The number of items to be refunded."
    quantity: Int!
}

input OrderRefundLineInput {
    "The ID of the order line to refund."
    orderLineId: ID!
    "The number of items to be refunded."
    quantity: Int!
}

input OrderRefundProductsInput {
    "The total amount of refund when the value is provided manually."
    amountToRefund: PositiveDecimal
    "List of fulfilled lines to refund."
    fulfillmentLines: [OrderRefundFulfillmentLineInput!]
    "If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored."
    includeShippingCosts: Boolean
    "List of unfulfilled lines to refund."
    orderLines: [OrderRefundLineInput!]
}

input OrderReturnFulfillmentLineInput {
    "The ID of the fulfillment line to return."
    fulfillmentLineId: ID!
    "The number of items to be returned."
    quantity: Int!
    "Determines, if the line should be added to replace order."
    replace: Boolean
}

input OrderReturnLineInput {
    "The ID of the order line to return."
    orderLineId: ID!
    "The number of items to be returned."
    quantity: Int!
    "Determines, if the line should be added to replace order."
    replace: Boolean
}

input OrderReturnProductsInput {
    "The total amount of refund when the value is provided manually."
    amountToRefund: PositiveDecimal
    "List of fulfilled lines to return."
    fulfillmentLines: [OrderReturnFulfillmentLineInput!]
    "If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored."
    includeShippingCosts: Boolean
    "List of unfulfilled lines to return."
    orderLines: [OrderReturnLineInput!]
    "If true, Saleor will call refund action for all lines."
    refund: Boolean
}

input OrderSettingsUpdateInput {
    "When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately."
    automaticallyConfirmAllNewOrders: Boolean
    "When enabled, all non-shippable gift card orders will be fulfilled automatically."
    automaticallyFulfillNonShippableGiftCard: Boolean
}

input OrderSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort orders by the selected field."
    field: OrderSortField!
}

input OrderUpdateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "Email address of the customer."
    userEmail: String
}

input OrderUpdateShippingInput {
    "ID of the selected shipping method, pass null to remove currently assigned shipping method."
    shippingMethod: ID
}

input PageCreateInput {
    "List of attributes."
    attributes: [AttributeValueInput!]
    "Page content in JSON format."
    content: JSONString
    "Determines if page is visible in the storefront."
    isPublished: Boolean
    "ID of the page type that page belongs to."
    pageType: ID!
    "Publication date. ISO 8601 standard."
    publicationDate: String
    "Search engine optimization fields."
    seo: SeoInput
    "Page internal name."
    slug: String
    "Page title."
    title: String
}

input PageFilterInput {
    ids: [ID]
    metadata: [MetadataFilter]
    pageTypes: [ID]
    search: String
}

input PageInput {
    "List of attributes."
    attributes: [AttributeValueInput!]
    "Page content in JSON format."
    content: JSONString
    "Determines if page is visible in the storefront."
    isPublished: Boolean
    "Publication date. ISO 8601 standard."
    publicationDate: String
    "Search engine optimization fields."
    seo: SeoInput
    "Page internal name."
    slug: String
    "Page title."
    title: String
}

input PageSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort pages by the selected field."
    field: PageSortField!
}

input PageTranslationInput {
    content: JSONString
    seoDescription: String
    seoTitle: String
    title: String
}

input PageTypeCreateInput {
    "List of attribute IDs to be assigned to the page type."
    addAttributes: [ID!]
    "Name of the page type."
    name: String
    "Page type slug."
    slug: String
}

input PageTypeFilterInput {
    search: String
}

input PageTypeSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort page types by the selected field."
    field: PageTypeSortField!
}

input PageTypeUpdateInput {
    "List of attribute IDs to be assigned to the page type."
    addAttributes: [ID!]
    "Name of the page type."
    name: String
    "List of attribute IDs to be assigned to the page type."
    removeAttributes: [ID!]
    "Page type slug."
    slug: String
}

input PaymentCheckBalanceInput {
    "Information about card."
    card: CardInput!
    "Slug of a channel for which the data should be returned."
    channel: String!
    "An ID of a payment gateway to check."
    gatewayId: String!
    "Payment method name."
    method: String!
}

input PaymentFilterInput {
    checkouts: [ID]
}

input PaymentInput {
    "Total amount of the transaction, including all taxes and discounts. If no amount is provided, the checkout total will be used."
    amount: PositiveDecimal
    "A gateway to use with that payment."
    gateway: String!
    "New in Saleor 3.1. User public metadata."
    metadata: [MetadataInput!]
    "URL of a storefront view where user should be redirected after requiring additional actions. Payment with additional actions will not be finished if this field is not provided."
    returnUrl: String
    "New in Saleor 3.1. Payment store type."
    storePaymentMethod: StorePaymentMethodEnum
    "Client-side generated payment token, representing customer's billing data in a secure manner."
    token: String
}

input PermissionGroupCreateInput {
    "List of permission code names to assign to this group."
    addPermissions: [PermissionEnum!]
    "List of users to assign to this group."
    addUsers: [ID!]
    "Group name."
    name: String!
}

input PermissionGroupFilterInput {
    ids: [ID]
    search: String
}

input PermissionGroupSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort permission group by the selected field."
    field: PermissionGroupSortField!
}

input PermissionGroupUpdateInput {
    "List of permission code names to assign to this group."
    addPermissions: [PermissionEnum!]
    "List of users to assign to this group."
    addUsers: [ID!]
    "Group name."
    name: String
    "List of permission code names to unassign from this group."
    removePermissions: [PermissionEnum!]
    "List of users to unassign from this group."
    removeUsers: [ID!]
}

input PluginFilterInput {
    search: String
    statusInChannels: PluginStatusInChannelsInput
    type: PluginConfigurationType
}

input PluginSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort plugins by the selected field."
    field: PluginSortField!
}

input PluginStatusInChannelsInput {
    active: Boolean!
    channels: [ID!]!
}

input PluginUpdateInput {
    "Indicates whether the plugin should be enabled."
    active: Boolean
    "Configuration of the plugin."
    configuration: [ConfigurationItemInput]
}

input PreorderSettingsInput {
    "The end date for preorder."
    endDate: DateTime
    "The global threshold for preorder variant."
    globalThreshold: Int
}

input PriceInput {
    "Amount of money."
    amount: PositiveDecimal!
    "Currency code."
    currency: String!
}

input PriceRangeInput {
    "Price greater than or equal to."
    gte: Float
    "Price less than or equal to."
    lte: Float
}

input ProductAttributeAssignInput {
    "The ID of the attribute to assign."
    id: ID!
    "The attribute type to be assigned as."
    type: ProductAttributeType!
    "New in Saleor 3.1. Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']."
    variantSelection: Boolean
}

input ProductAttributeAssignmentUpdateInput {
    "The ID of the attribute to assign."
    id: ID!
    "New in Saleor 3.1. Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']."
    variantSelection: Boolean!
}

input ProductChannelListingAddInput {
    "List of variants to which the channel should be assigned."
    addVariants: [ID!]
    "A start date from which a product will be available for purchase. When not set and isAvailable is set to True, the current day is assumed."
    availableForPurchaseDate: Date
    "ID of a channel."
    channelId: ID!
    "Determine if product should be available for purchase."
    isAvailableForPurchase: Boolean
    "Determines if object is visible to customers."
    isPublished: Boolean
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "List of variants from which the channel should be unassigned."
    removeVariants: [ID!]
    "Determines if product is visible in product listings (doesn't apply to product collections)."
    visibleInListings: Boolean
}

input ProductChannelListingUpdateInput {
    "List of channels from which the product should be unassigned."
    removeChannels: [ID!]
    "List of channels to which the product should be assigned or updated."
    updateChannels: [ProductChannelListingAddInput!]
}

input ProductCreateInput {
    "List of attributes."
    attributes: [AttributeValueInput!]
    "ID of the product's category."
    category: ID
    "Determine if taxes are being charged for the product."
    chargeTaxes: Boolean
    "List of IDs of collections that the product belongs to."
    collections: [ID!]
    "Product description (JSON)."
    description: JSONString
    "Product name."
    name: String
    "ID of the type that product belongs to."
    productType: ID!
    "Defines the product rating value."
    rating: Float
    "Search engine optimization fields."
    seo: SeoInput
    "Product slug."
    slug: String
    "Tax rate for enabled tax gateway."
    taxCode: String
    "Weight of the Product."
    weight: WeightScalar
}

input ProductFilterInput {
    attributes: [AttributeInput]
    categories: [ID]
    """

    Specifies the channel by which the data should be filtered.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    collections: [ID]
    giftCard: Boolean
    hasCategory: Boolean
    hasPreorderedVariants: Boolean
    ids: [ID]
    isPublished: Boolean
    metadata: [MetadataFilter]
    minimalPrice: PriceRangeInput
    price: PriceRangeInput
    productTypes: [ID]
    search: String
    stockAvailability: StockAvailability
    stocks: ProductStockFilterInput
    updatedAt: DateTimeRangeInput
}

input ProductInput {
    "List of attributes."
    attributes: [AttributeValueInput!]
    "ID of the product's category."
    category: ID
    "Determine if taxes are being charged for the product."
    chargeTaxes: Boolean
    "List of IDs of collections that the product belongs to."
    collections: [ID!]
    "Product description (JSON)."
    description: JSONString
    "Product name."
    name: String
    "Defines the product rating value."
    rating: Float
    "Search engine optimization fields."
    seo: SeoInput
    "Product slug."
    slug: String
    "Tax rate for enabled tax gateway."
    taxCode: String
    "Weight of the Product."
    weight: WeightScalar
}

input ProductMediaCreateInput {
    "Alt text for a product media."
    alt: String
    "Represents an image file in a multipart request."
    image: Upload
    "Represents an URL to an external media."
    mediaUrl: String
    "ID of an product."
    product: ID!
}

input ProductMediaUpdateInput {
    "Alt text for a product media."
    alt: String
}

input ProductOrder {
    """

    Sort product by the selected attribute's values.
    Note: this doesn't take translations into account yet.
    """
    attributeId: ID
    """

    Specifies the channel in which to sort the data.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort products by the selected field."
    field: ProductOrderField
}

input ProductStockFilterInput {
    quantity: IntRangeInput
    warehouseIds: [ID!]
}

input ProductTypeFilterInput {
    configurable: ProductTypeConfigurable
    ids: [ID]
    kind: ProductTypeKindEnum
    metadata: [MetadataFilter]
    productType: ProductTypeEnum
    search: String
}

input ProductTypeInput {
    "Determines if product of this type has multiple variants. This option mainly simplifies product management in the dashboard. There is always at least one variant created under the hood."
    hasVariants: Boolean
    "Determines if products are digital."
    isDigital: Boolean
    "Determines if shipping is required for products of this variant."
    isShippingRequired: Boolean
    "The product type kind."
    kind: ProductTypeKindEnum
    "Name of the product type."
    name: String
    "List of attributes shared among all product variants."
    productAttributes: [ID]
    "Product type slug."
    slug: String
    "Tax rate for enabled tax gateway."
    taxCode: String
    "List of attributes used to distinguish between different variants of a product."
    variantAttributes: [ID]
    "Weight of the ProductType items."
    weight: WeightScalar
}

input ProductTypeSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort product types by the selected field."
    field: ProductTypeSortField!
}

input ProductVariantBulkCreateInput {
    "List of attributes specific to this variant."
    attributes: [BulkAttributeValueInput!]!
    "List of prices assigned to channels."
    channelListings: [ProductVariantChannelListingAddInput!]
    "New in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point."
    preorder: PreorderSettingsInput
    "New in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    quantityLimitPerCustomer: Int
    "Stock keeping unit."
    sku: String
    "Stocks of a product available for sale."
    stocks: [StockInput!]
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input ProductVariantChannelListingAddInput {
    "ID of a channel."
    channelId: ID!
    "Cost price of the variant in channel."
    costPrice: PositiveDecimal
    "New in Saleor 3.1. The threshold for preorder variant in channel. Note: this feature is in a preview state and can be subject to changes at later point."
    preorderThreshold: Int
    "Price of the particular variant in channel."
    price: PositiveDecimal!
}

input ProductVariantCreateInput {
    "List of attributes specific to this variant."
    attributes: [AttributeValueInput!]!
    "New in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point."
    preorder: PreorderSettingsInput
    "Product ID of which type is the variant."
    product: ID!
    "New in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    quantityLimitPerCustomer: Int
    "Stock keeping unit."
    sku: String
    "Stocks of a product available for sale."
    stocks: [StockInput!]
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input ProductVariantFilterInput {
    isPreorder: Boolean
    metadata: [MetadataFilter]
    search: String
    sku: [String]
    updatedAt: DateTimeRangeInput
}

input ProductVariantInput {
    "List of attributes specific to this variant."
    attributes: [AttributeValueInput!]
    "New in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point."
    preorder: PreorderSettingsInput
    "New in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point."
    quantityLimitPerCustomer: Int
    "Stock keeping unit."
    sku: String
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input PublishableChannelListingInput {
    "ID of a channel."
    channelId: ID!
    "Determines if object is visible to customers."
    isPublished: Boolean
    "Publication date. ISO 8601 standard."
    publicationDate: Date
}

input ReorderInput {
    "The ID of the item to move."
    id: ID!
    "The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input SaleChannelListingAddInput {
    "ID of a channel."
    channelId: ID!
    "The value of the discount."
    discountValue: PositiveDecimal!
}

input SaleChannelListingInput {
    "List of channels to which the sale should be assigned."
    addChannels: [SaleChannelListingAddInput!]
    "List of channels from which the sale should be unassigned."
    removeChannels: [ID!]
}

input SaleFilterInput {
    metadata: [MetadataFilter]
    saleType: DiscountValueTypeEnum
    search: String
    started: DateTimeRangeInput
    status: [DiscountStatusEnum]
    updatedAt: DateTimeRangeInput
}

input SaleInput {
    "Categories related to the discount."
    categories: [ID]
    "Collections related to the discount."
    collections: [ID]
    "End date of the voucher in ISO 8601 format."
    endDate: DateTime
    "Voucher name."
    name: String
    "Products related to the discount."
    products: [ID]
    "Start date of the voucher in ISO 8601 format."
    startDate: DateTime
    "Fixed or percentage."
    type: DiscountValueTypeEnum
    "Value of the voucher."
    value: PositiveDecimal
    variants: [ID]
}

input SaleSortingInput {
    """

    Specifies the channel in which to sort the data.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort sales by the selected field."
    field: SaleSortField!
}

input SeoInput {
    "SEO description."
    description: String
    "SEO title."
    title: String
}

input ShippingMethodChannelListingAddInput {
    "ID of a channel."
    channelId: ID!
    "Maximum order price to use this shipping method."
    maximumOrderPrice: PositiveDecimal
    "Minimum order price to use this shipping method."
    minimumOrderPrice: PositiveDecimal
    "Shipping price of the shipping method in this channel."
    price: PositiveDecimal
}

input ShippingMethodChannelListingInput {
    "List of channels to which the shipping method should be assigned."
    addChannels: [ShippingMethodChannelListingAddInput!]
    "List of channels from which the shipping method should be unassigned."
    removeChannels: [ID!]
}

input ShippingPostalCodeRulesCreateInputRange {
    "End range of the postal code."
    end: String
    "Start range of the postal code."
    start: String!
}

input ShippingPriceExcludeProductsInput {
    "List of products which will be excluded."
    products: [ID]!
}

input ShippingPriceInput {
    "Postal code rules to add."
    addPostalCodeRules: [ShippingPostalCodeRulesCreateInputRange!]
    "Postal code rules to delete."
    deletePostalCodeRules: [ID!]
    "Shipping method description."
    description: JSONString
    "Inclusion type for currently assigned postal code rules."
    inclusionType: PostalCodeRuleInclusionTypeEnum
    "Maximum number of days for delivery."
    maximumDeliveryDays: Int
    "Maximum order weight to use this shipping method."
    maximumOrderWeight: WeightScalar
    "Minimal number of days for delivery."
    minimumDeliveryDays: Int
    "Minimum order weight to use this shipping method."
    minimumOrderWeight: WeightScalar
    "Name of the shipping method."
    name: String
    "Shipping zone this method belongs to."
    shippingZone: ID
    "Shipping type: price or weight based."
    type: ShippingMethodTypeEnum
}

input ShippingPriceTranslationInput {
    "Translated shipping method description (JSON)."
    description: JSONString
    name: String
}

input ShippingZoneCreateInput {
    "List of channels to assign to the shipping zone."
    addChannels: [ID!]
    "List of warehouses to assign to a shipping zone"
    addWarehouses: [ID]
    "List of countries in this shipping zone."
    countries: [String]
    "Default shipping zone will be used for countries not covered by other zones."
    default: Boolean
    "Description of the shipping zone."
    description: String
    "Shipping zone's name. Visible only to the staff."
    name: String
}

input ShippingZoneFilterInput {
    channels: [ID]
    search: String
}

input ShippingZoneUpdateInput {
    "List of channels to assign to the shipping zone."
    addChannels: [ID!]
    "List of warehouses to assign to a shipping zone"
    addWarehouses: [ID]
    "List of countries in this shipping zone."
    countries: [String]
    "Default shipping zone will be used for countries not covered by other zones."
    default: Boolean
    "Description of the shipping zone."
    description: String
    "Shipping zone's name. Visible only to the staff."
    name: String
    "List of channels to unassign from the shipping zone."
    removeChannels: [ID!]
    "List of warehouses to unassign from a shipping zone"
    removeWarehouses: [ID]
}

input ShopSettingsInput {
    "Enable automatic fulfillment for all digital products."
    automaticFulfillmentDigitalProducts: Boolean
    "Charge taxes on shipping."
    chargeTaxesOnShipping: Boolean
    "URL of a view where customers can set their password."
    customerSetPasswordUrl: String
    "Default number of max downloads per digital content URL."
    defaultDigitalMaxDownloads: Int
    "Default number of days which digital content URL will be valid."
    defaultDigitalUrlValidDays: Int
    "Default email sender's address."
    defaultMailSenderAddress: String
    "Default email sender's name."
    defaultMailSenderName: String
    "Default weight unit."
    defaultWeightUnit: WeightUnitsEnum
    "SEO description."
    description: String
    "Display prices with tax in store."
    displayGrossPrices: Boolean
    "New in Saleor 3.1. Enable ability to approve fulfillments which are unpaid."
    fulfillmentAllowUnpaid: Boolean
    "New in Saleor 3.1. Enable automatic approval of all new fulfillments."
    fulfillmentAutoApprove: Boolean
    "Header text."
    headerText: String
    "Include taxes in prices."
    includeTaxesInPrices: Boolean
    "New in Saleor 3.1. Default number of maximum line quantity in single checkout. Minimum possible value is 1, default value is 50. Note: this feature is in a preview state and can be subject to changes at later point."
    limitQuantityPerCheckout: Int
    "New in Saleor 3.1. Default number of minutes stock will be reserved for anonymous checkout. Enter 0 or null to disable."
    reserveStockDurationAnonymousUser: Int
    "New in Saleor 3.1. Default number of minutes stock will be reserved for authenticated checkout. Enter 0 or null to disable."
    reserveStockDurationAuthenticatedUser: Int
    "Enable inventory tracking."
    trackInventoryByDefault: Boolean
}

input ShopSettingsTranslationInput {
    description: String
    headerText: String
}

input SiteDomainInput {
    "Domain name for shop."
    domain: String
    "Shop site name."
    name: String
}

input StaffCreateInput {
    "List of permission group IDs to which user should be assigned."
    addGroups: [ID!]
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "URL of a view where users should be redirected to set the password. URL in RFC 1808 format."
    redirectUrl: String
}

input StaffNotificationRecipientInput {
    "Determines if a notification active."
    active: Boolean
    "Email address of a user subscribed to email notifications."
    email: String
    "The ID of the user subscribed to email notifications.."
    user: ID
}

input StaffUpdateInput {
    "List of permission group IDs to which user should be assigned."
    addGroups: [ID!]
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "List of permission group IDs from which user should be unassigned."
    removeGroups: [ID!]
}

input StaffUserInput {
    ids: [ID]
    search: String
    status: StaffMemberStatus
}

input StockFilterInput {
    quantity: Float
    search: String
}

input StockInput {
    "Quantity of items available for sell."
    quantity: Int!
    "Warehouse in which stock is located."
    warehouse: ID!
}

input TimePeriodInputType {
    "The length of the period."
    amount: Int!
    "The type of the period."
    type: TimePeriodTypeEnum!
}

input TranslationInput {
    description: JSONString
    name: String
    seoDescription: String
    seoTitle: String
}

input UpdateInvoiceInput {
    "Invoice number"
    number: String
    "URL of an invoice to download."
    url: String
}

input UserCreateInput {
    "Slug of a channel which will be used for notify user. Optional when only one channel exists."
    channel: String
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "User language code."
    languageCode: LanguageCodeEnum
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "URL of a view where users should be redirected to set the password. URL in RFC 1808 format."
    redirectUrl: String
}

input UserSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort users by the selected field."
    field: UserSortField!
}

input VoucherChannelListingAddInput {
    "ID of a channel."
    channelId: ID!
    "Value of the voucher."
    discountValue: PositiveDecimal
    "Min purchase amount required to apply the voucher."
    minAmountSpent: PositiveDecimal
}

input VoucherChannelListingInput {
    "List of channels to which the voucher should be assigned."
    addChannels: [VoucherChannelListingAddInput!]
    "List of channels from which the voucher should be unassigned."
    removeChannels: [ID!]
}

input VoucherFilterInput {
    discountType: [VoucherDiscountType]
    metadata: [MetadataFilter]
    search: String
    started: DateTimeRangeInput
    status: [DiscountStatusEnum]
    timesUsed: IntRangeInput
}

input VoucherInput {
    "Voucher should be applied once per customer."
    applyOncePerCustomer: Boolean
    "Voucher should be applied to the cheapest item or entire order."
    applyOncePerOrder: Boolean
    "Categories discounted by the voucher."
    categories: [ID]
    "Code to use the voucher."
    code: String
    "Collections discounted by the voucher."
    collections: [ID]
    "Country codes that can be used with the shipping voucher."
    countries: [String]
    "Choices: fixed or percentage."
    discountValueType: DiscountValueTypeEnum
    "End date of the voucher in ISO 8601 format."
    endDate: DateTime
    "Minimal quantity of checkout items required to apply the voucher."
    minCheckoutItemsQuantity: Int
    "Voucher name."
    name: String
    "Voucher can be used only by staff user."
    onlyForStaff: Boolean
    "Products discounted by the voucher."
    products: [ID]
    "Start date of the voucher in ISO 8601 format."
    startDate: DateTime
    "Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER."
    type: VoucherTypeEnum
    "Limit number of times this voucher can be used in total."
    usageLimit: Int
    "New in Saleor 3.1. Variants discounted by the voucher."
    variants: [ID]
}

input VoucherSortingInput {
    """

    Specifies the channel in which to sort the data.

    DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
    """
    channel: String
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort vouchers by the selected field."
    field: VoucherSortField!
}

input WarehouseCreateInput {
    "Address of the warehouse."
    address: AddressInput!
    "The email address of the warehouse."
    email: String
    "Warehouse name."
    name: String!
    "Shipping zones supported by the warehouse."
    shippingZones: [ID]
    "Warehouse slug."
    slug: String
}

input WarehouseFilterInput {
    clickAndCollectOption: WarehouseClickAndCollectOptionEnum
    ids: [ID]
    isPrivate: Boolean
    search: String
}

input WarehouseSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort warehouses by the selected field."
    field: WarehouseSortField!
}

input WarehouseUpdateInput {
    "Address of the warehouse."
    address: AddressInput
    "New in Saleor 3.1. Click and collect options: local, all or disabled. Note: this feature is in a preview state and can be subject to changes at later point."
    clickAndCollectOption: WarehouseClickAndCollectOptionEnum
    "The email address of the warehouse."
    email: String
    "New in Saleor 3.1. Visibility of warehouse stocks. Note: this feature is in a preview state and can be subject to changes at later point."
    isPrivate: Boolean
    "Warehouse name."
    name: String
    "Warehouse slug."
    slug: String
}

input WebhookCreateInput {
    "ID of the app to which webhook belongs."
    app: ID
    "The asynchronous events that webhook wants to subscribe."
    asyncEvents: [WebhookEventTypeAsyncEnum!]
    """

    The events that webhook wants to subscribe.

    DEPRECATED: this field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.
    """
    events: [WebhookEventTypeEnum]
    "Determine if webhook will be set active or not."
    isActive: Boolean
    "The name of the webhook."
    name: String
    "The secret key used to create a hash signature with each payload."
    secretKey: String
    "The synchronous events that webhook wants to subscribe."
    syncEvents: [WebhookEventTypeSyncEnum!]
    "The url to receive the payload."
    targetUrl: String
}

input WebhookUpdateInput {
    "ID of the app to which webhook belongs."
    app: ID
    "The asynchronous events that webhook wants to subscribe."
    asyncEvents: [WebhookEventTypeAsyncEnum!]
    """

    The events that webhook wants to subscribe.

    DEPRECATED: this field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.
    """
    events: [WebhookEventTypeEnum]
    "Determine if webhook will be set active or not."
    isActive: Boolean
    "The new name of the webhook."
    name: String
    "Use to create a hash signature with each payload."
    secretKey: String
    "The synchronous events that webhook wants to subscribe."
    syncEvents: [WebhookEventTypeSyncEnum!]
    "The url to receive the payload."
    targetUrl: String
}
